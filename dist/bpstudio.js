!function(t,e){"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?module.exports=e():t.BPStudio=e()}(this,(function(){var t=this&&this.__decorate||function(t,e,i,s){var n,r=arguments.length,o=r<3?e:null===s?s=Object.getOwnPropertyDescriptor(e,i):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,i,s);else for(var h=t.length-1;h>=0;h--)(n=t[h])&&(o=(r<3?n(o):r>3?n(e,i,o):n(e,i))||o);return r>3&&o&&Object.defineProperty(e,i,o),o};if("object"!=typeof Shrewd)throw new Error("BPStudio requires Shrewd.");const{shrewd:e}=Shrewd;Shrewd.option.autoCommit=!1,setInterval((()=>Shrewd.commit()),50);let i=!1;function s(t,e){if(void 0===e)return(e,i)=>n(e,i,t);n(t,e,{})}function n(t,i,s){e({validator(t){var e,n;let o=r.get(this);o||r.set(this,o={});let h=null===(n=null===(e=s.validator)||void 0===e?void 0:e.apply(this,[t]))||void 0===n||n;if(h){if(i in o&&o[i]!=t){if(!("design"in this))debugger;this.design.history.fieldChange(this,i,o[i],t)}o[i]=t}return h}})(t,i)}const r=new WeakMap;function o(t,e,i){let s=i.get;return{get(){let t=h.get(this);return t||h.set(this,t={}),e in t?t[e]:t[e]=s.apply(this)},enumerable:!1,configurable:!1}}const h=new WeakMap;class l{constructor(t,e){this.configuration=t,this.overlaps=e.overlaps,this.strategy=e.strategy}static getMaxIntersectionDistance(t,e,i,s){let n=s?2:0,r=t.node.get(e.c[n].e),o=t.node.get(i.c[n].e),h=t.node.get(e.c[2-n].e);return t.distTriple(r,o,h).d3}*generate(){let{strategy:t}=this;if(1==this.overlaps.length){let e=this.overlaps[0],i=this.configuration.repository.structure[e.parent];if(t==Rt.halfIntegral)for(let t of this.halfKamiya(e,i.sx))yield{gadgets:[t]};if(t==Rt.universal)for(let t of this.universalGPS(e,i.sx))yield{gadgets:[t]};else for(let t of c.gops(e,i.sx))yield{gadgets:[{pieces:[t]}]}}if(2==this.overlaps.length){let e=this.configuration.repository.getJoiner(this.overlaps);t==Rt.baseJoin?yield*e.baseJoin():t==Rt.standardJoin?yield*e.standardJoin():yield*e.simpleJoin(t)}}*universalGPS(t,e){let i=2,s=!1;for(;!s;){let n=Ht(t);n.ox*=i,n.oy*=i;for(let t of c.gops(n,e*i)){let e=c.instantiate(t).shrink(i);if(!Number.isInteger(e.v))continue;let{ox:n,oy:r,u:o,v:h}=e,l={ox:n,oy:r,u:h,v:o},a={x:0,y:0},d={x:r+o+h,y:n+o+h};e.detours=[[a,d]],l.detours=[[d,a]];let u=e.oy+e.u+e.v,p=Math.ceil(u)-u,g=new jt({pieces:[e,l]}),f=g.reverseGPS();yield g.addSlack(2,p),yield f.addSlack(0,p),s=!0}i+=2}}*halfKamiya(t,e){if(t.ox%2==0||t.oy%2==0)return;let i=Ht(t);i.ox<<=1,i.oy<<=1;for(let t of c.gops(i,2*e)){let e=c.instantiate(t);if(e.rank>3)continue;let i=e.v%2==0;if(e.ox==e.oy&&i)continue;let{ox:s,oy:n,u:r,v:o}=e.shrink(2),h=Math.abs(s-n)/2;if(!Number.isInteger(h))debugger;let l,a=Math.min(s,n);if(i&&s>=n)e.detours=[[{x:h,y:3*h},{x:n+r+o,y:s+r+o}]],l={ox:a,oy:a,u:o,v:r-h,detours:[[{x:a+r+o-h,y:a+r+o-h},{x:0,y:0}]],shift:{x:h,y:3*h}};else{if(i||!(n>=s))continue;e.detours=[[{x:n+r+o,y:s+r+o},{x:3*h,y:h}]],l={ox:a,oy:a,u:o-h,v:r,detours:[[{x:0,y:0},{x:a+r+o-h,y:a+r+o-h}]],shift:{x:3*h,y:h}}}let d=new jt({pieces:[e,l]}),u=d.reverseGPS();yield d.addSlack(2,.5),yield u.addSlack(0,.5)}}}class a{get axisParallels(){let t=this.shape.contour.find((t=>t.isIntegral)),e=this.direction,i=e.rotate90().normalize(),s=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;for(let e of this.shape.contour){let r=e.sub(t).dot(i);r>n&&(n=r),r<s&&(s=r)}let r=[];for(let o=Math.ceil(s);o<=Math.floor(n);o++){let s=t.add(i.scale(o)),n=[];for(let t of this.shape.ridges){let i=t.intersection(s,e);if(i&&!i.eq(n[0])&&n.push(i),2==n.length)break}2==n.length&&r.push(new Nt(...n))}return r}}t([o],a.prototype,"axisParallels",null);let d=class{constructor(t){this._disposed=!1,this._disposeWith=t}_disposeEvent(){this.disposed&&(Shrewd.terminate(this),this.onDispose())}get shouldDispose(){return!!this._disposeWith&&this._disposeWith.disposed}dispose(){this._disposed=!0}onDispose(){}get disposed(){return this._disposed}};t([e({renderer(t){return t||this.shouldDispose}})],d.prototype,"_disposed",void 0),t([e],d.prototype,"_disposeEvent",null),t([e],d.prototype,"disposed",null),d=t([e],d);class c extends a{constructor(t){super(),zt(this,t)}get _points(){let{ox:t,oy:e,u:i,v:s}=this,n=[T.ZERO,new T(i,t+i),new T(e+i+s,t+i+s),new T(e+s,s)];return n.forEach((t=>t.addBy(this._shift))),n}get _shift(){var t,e,i,s,n,r,o,h;return new R((null!==(e=null===(t=this.shift)||void 0===t?void 0:t.x)&&void 0!==e?e:0)+(null!==(s=null===(i=this._offset)||void 0===i?void 0:i.x)&&void 0!==s?s:0),(null!==(r=null===(n=this.shift)||void 0===n?void 0:n.y)&&void 0!==r?r:0)+(null!==(h=null===(o=this._offset)||void 0===o?void 0:o.y)&&void 0!==h?h:0))}get shape(){let t=this._points.concat(),e=t.map(((t,e,i)=>new Nt(t,i[(e+1)%i.length])));return(this.detours||[]).forEach((i=>{let s=i.map((t=>new T(t.x,t.y).addBy(this._shift))),n=s[0],r=s[s.length-1],o=[];for(let t=0;t<s.length-1;t++)o.push(new Nt(s[t],s[t+1]));let h=e.length;for(let i=0;i<h;i++){let l=e[i].p1.eq(n);if(l||e[i].contains(n)){for(let a=1;a<h;a++){let d=(a+i)%h;if(e[d].p1.eq(r)||e[d].contains(r)){let c=d<i?h-i:a+1,u=a+1-c,p=s.concat();return o.push(new Nt(r,e[d].p2)),l||(p.unshift(e[i].p1),o.unshift(new Nt(e[i].p1,n))),t.splice(i,c,...p),e.splice(i,c,...o),t.splice(0,u),void e.splice(0,u)}}debugger}}})),{contour:t,ridges:e}}get anchors(){let t=this._points,{contour:e}=this.shape;return[e.some((e=>e.eq(t[0])))?t[0]:null,e.includes(t[1])?t[1]:null,e.some((e=>e.eq(t[2])))?t[2]:null,e.includes(t[3])?t[3]:null]}get direction(){let{oy:t,v:e}=this;return new R(t+e,e).doubleAngle()}get sx(){return this.oy+this.u+this.v}get sy(){return this.ox+this.u+this.v}get rank(){let t=Ft.reduce(this.oy+this.v,this.oy)[0],e=Ft.reduce(this.ox+this.u,this.ox)[0];return Math.max(t,e)}reverse(t,e){let{shift:i,detours:s,sx:n,sy:r}=this;i=i||{x:0,y:0};let o={x:t-n-i.x,y:e-r-i.y};(o.x||o.y)&&(this.shift=o),null==s||s.forEach((t=>t.forEach((t=>{t.x=n-t.x,t.y=r-t.y}))))}shrink(t=2){return h.delete(this),this.ox/=t,this.oy/=t,this.u/=t,this.v/=t,this}offset(t){!t||this._offset&&this._offset.x==t.x&&this._offset.y==t.y||(this._offset=t,h.delete(this))}addDetour(t){t=Ht(t);for(let e=0;e<t.length-1;e++)t[e].x==t[e+1].x&&t[e].y==t[e+1].y&&t.splice(e--,1);1!=t.length&&(this.detours=this.detours||[],this.detours.push(t),h.delete(this))}clearDetour(){var t;(null===(t=this.detours)||void 0===t?void 0:t.length)&&(this.detours=void 0,h.delete(this))}toJSON(){return Ht(this)}static*gops(t,e){let{ox:i,oy:s}=t;if([i,s].some((t=>!Number.isSafeInteger(t))))return;if(i%2&&s%2)return;void 0===e&&(e=Number.POSITIVE_INFINITY);let n=i*s/2;for(let t,r=Math.floor(Math.sqrt(n));r>0&&r+(t=n/r)+s<=e;r--)if(n%r==0&&(r==t&&(yield{ox:i,oy:s,u:r,v:t}),r!=t)){let e=new c({ox:i,oy:s,u:r,v:t}),n=new c({ox:i,oy:s,u:t,v:r});e.rank>n.rank?(yield n,yield e):(yield e,yield n)}}static instantiate(t,e=!1){return t instanceof c&&!e?t:new c(t)}}t([o],c.prototype,"_points",null),t([function(t,e,i){if(i)return i.enumerable=!1,i;Object.defineProperty(t,e,{set(t){Object.defineProperty(this,e,{value:t,writable:!0,configurable:!1})},configurable:!0})}],c.prototype,"_offset",void 0),t([o],c.prototype,"_shift",null),t([o],c.prototype,"shape",null),t([o],c.prototype,"anchors",null),t([o],c.prototype,"direction",null),t([o],c.prototype,"rank",null);class u extends a{constructor(t){super(),this.contour=t.contour,this.dir=t.dir}get shape(){let t=this.contour.map((t=>new T(t))),e=t.map(((t,e,i)=>new Nt(t,i[(e+1)%i.length])));return{contour:t,ridges:e}}get direction(){return new R(this.dir)}static instantiate(t){return t instanceof u?t:new u(t)}}t([o],u.prototype,"shape",null),t([o],u.prototype,"direction",null);let p=class{constructor(){this._map=new Map,this._size=0}set(t,e,i){return this.has(t,e)||(this._map.has(t)||this._map.set(t,new Map),this._map.has(e)||this._map.set(e,new Map),this._size++),this._map.get(t).set(e,i),this._map.get(e).set(t,i),this}get[Symbol.toStringTag](){return"DoubleMap"}has(...t){return this._size,1==t.length?this._map.has(t[0]):this._map.has(t[0])&&this._map.get(t[0]).has(t[1])}get(...t){return this._size,1==t.length?this._map.get(t[0]):this.has(t[0],t[1])?this._map.get(t[0]).get(t[1]):void 0}get size(){return this._size}clear(){this._map.clear(),this._size=0}forEach(t,e){e||(e=this);for(let[i,s,n]of this.entries())t.apply(e,[n,i,s,this])}delete(...t){if(1==t.length){if(!this._map.has(t[0]))return!1;this._size-=this._map.get(t[0]).size,this._map.delete(t[0]);for(let e of this._map.values())e.delete(t[0]);return!0}return!!this.has(t[0],t[1])&&(this._map.get(t[0]).delete(t[1]),this._map.get(t[1]).delete(t[0]),this._size--,!0)}[Symbol.iterator](){return this.entries()}*entries(){for(let[t,e]of this.keys())yield[t,e,this.get(t,e)]}*keys(){this._size;let t=new Map;for(let e of this._map.keys()){t.set(e,new Set);for(let i of this._map.get(e).keys())t.has(i)&&t.get(i).has(e)||(t.get(e).add(i),yield[e,i])}}firstKeys(){return this._size,this._map.keys()}*values(){for(let[t,e]of this.keys())yield this.get(t,e)}};t([e],p.prototype,"_size",void 0),p=t([e],p);class g{constructor(t,e,i,s){this.source=t,this.keyGen=e,this.ctor=i,this.dtor=s,this._map=new Map}render(){for(let[t,e]of this._map)this.dtor(t,e)&&this._map.delete(t);for(let t of this.source()){let e=this.keyGen(t);this._map.has(e)||this._map.set(e,this.ctor(t))}return new Map(this._map)}get(t){return this.render().get(t)}has(t){return this.render().has(t)}forEach(t,e){return this.render().forEach(t,e)}get size(){return this.render().size}[Symbol.iterator](){return this.render()[Symbol.iterator]()}entries(){return this.render().entries()}keys(){return this.render().keys()}values(){return this.render().values()}toJSON(){return Array.from(this.values()).map((t=>t.toJSON()))}}t([e],g.prototype,"render",null);let f=class{constructor(t,e){this._source=t,this._constructor=e,this._map=new p}dispose(){Shrewd.terminate(this._map),Shrewd.terminate(this)}has(...t){return this._map.has.apply(this._map,t)}get(...t){return this._map.get.apply(this._map,t)}get size(){return this._map.size}forEach(t,e){return this._map.forEach(t,e)}[Symbol.iterator](){return this._map[Symbol.iterator]()}entries(){return this._map.entries()}keys(){return this._map.keys()}firstKeys(){return this._map.firstKeys()}values(){return this._map.values()}};t([e({renderer(t){for(let e of t.firstKeys())e.disposed&&t.delete(e);let e=Array.from(this._source());e.length>1&&0==t.size&&t.set(e[0],e[1],this._constructor(e[0],e[1]));for(let i of e)if(!t.has(i)){let e=Array.from(t.firstKeys());for(let s of e)t.set(i,s,this._constructor(i,s))}return t}})],f.prototype,"_map",void 0),f=t([e],f),window.BigInt=window.BigInt||(t=>t);const y=BigInt(1);class v{constructor(t,e=1){if(t instanceof v)this._p=t._p,this._q=t._q*BigInt(e);else if("bigint"==typeof t&&"bigint"==typeof e)this._p=t,this._q=e;else if("bigint"==typeof t&&1===e)this._p=t,this._q=y;else{if("number"!=typeof t||"number"!=typeof e){debugger;throw new Error("Parameters are not valid")}if(Number.isSafeInteger(t)&&Number.isSafeInteger(e))this._p=BigInt(t),this._q=BigInt(e);else{if(!Number.isFinite(t/e)){debugger;throw new Error("Parameters are not valid")}{let i=v.toFraction(t/e);this._p=i._p,this._q=i._q}}}}static toFraction(t,e=1,i=0,s=v.ERROR){let n=Math.floor(t),r=t-n,o=n*i+e;return r/o/((1-r)*o+i)<s?new v(n):v.toFraction(1/r,i,o).i().a(n)}get $numerator(){return this._p}get $denominator(){return this._q}get value(){return Number(this._p)/Number(this._q)}toString(){return this.smp(),this._p+(this._q>1?"/"+this._q:"")}c(){return new v(this._p,this._q)}smp(){return[this._p,this._q]=Ft.reduce(this._p,this._q),this._check()}n(){return this._p=-this._p,this}i(){return[this._p,this._q]=[this._q,this._p],this}r(){return this._p=BigInt(Math.round(this.value)),this._q=y,this}a(t){return t instanceof v?(this._p=this._p*t._q+this._q*t._p,this._q*=t._q):Number.isInteger(t)?this._p+=BigInt(t)*this._q:this.a(new v(t)),this}s(t){return t instanceof v?(this._p=this._p*t._q-this._q*t._p,this._q*=t._q):Number.isInteger(t)?this._p-=BigInt(t)*this._q:this.s(new v(t)),this}m(t){return t instanceof v?(this._p*=t._p,this._q*=t._q):Number.isInteger(t)?this._p*=BigInt(t):this.m(new v(t)),this._check()}d(t){return t instanceof v?(this._p*=t._q,this._q*=t._p):Number.isInteger(t)?this._q*=BigInt(t):this.d(new v(t)),this._check()}_check(){return this._q<0&&(this._q=-this._q,this._p=-this._p),this}get neg(){return this.c().n()}get inv(){return this.c().i()}add(t){return this.c().a(t)}sub(t){return this.c().s(t)}mul(t){return this.c().m(t)}div(t){return this.c().d(t)}eq(t){return t instanceof v?this._p*t._q==this._q*t._p:this._p==this._q*BigInt(t)}ne(t){return t instanceof v?this._p*t._q!=this._q*t._p:Number.isSafeInteger(t)?this._p!=this._q*BigInt(t):this.ne(new v(t))}lt(t){return t instanceof v?this._p*t._q<this._q*t._p:Number.isSafeInteger(t)?this._p<this._q*BigInt(t):this.lt(new v(t))}gt(t){return t instanceof v?this._p*t._q>this._q*t._p:Number.isSafeInteger(t)?this._p>this._q*BigInt(t):this.gt(new v(t))}le(t){return t instanceof v?this._p*t._q<=this._q*t._p:Number.isSafeInteger(t)?this._p<=this._q*BigInt(t):this.le(new v(t))}ge(t){return t instanceof v?this._p*t._q>=this._q*t._p:Number.isSafeInteger(t)?this._p>=this._q*BigInt(t):this.ge(new v(t))}toJSON(){return this.toString()}}v.ERROR=1e-12;class _ extends l{constructor(t,e){super(t,e),this.cornerMap=[];for(let[t,i]of e.overlaps.entries())for(let[e,s]of i.c.entries())this.cornerMap.push([s,t,e])}get intersectionCorners(){return this.cornerMap.filter((t=>{let e=t[0].type;return e==mt.side||e==mt.intersection}))}get outCorners(){return this.intersectionCorners.concat(this.cornerMap.filter((t=>t[0].type==mt.flap)))}get constraints(){return this.cornerMap.filter((t=>{let e=t[0].type;return e==mt.socket||e==mt.internal||e==mt.flap}))}getOriginalDisplacement(t){let e=this.overlaps.find((t=>t.c[0].type!=mt.coincide));return t.getConnectionTarget(e.c[0]).sub(this.configuration.repository.stretch.origin)}get _sideConnectionTarget(){let t=new Map,e=this.configuration.sheet.design.flapsById;for(let[i,s,n]of this.intersectionCorners){let r=this.overlaps[s],o=this.getParent(r),[h,l]=[o.c[0],o.c[2]],[a,d]=[e.get(h.e),e.get(l.e)],c=a.quadrants[h.q],u=0,p=d.quadrants[l.q],g=0;if(i.type==mt.intersection){let t=r.c[0].e<0,e=this.configuration.sheet.design.tree,s=e.node.get(i.e),n=e.distTriple(a.node,d.node,s);if(t?g=n.d2-d.radius:u=n.d1-a.radius,isNaN(u)||isNaN(g))debugger}r=this.getExposedOverlap(r);let f=c.getOverlapCorner(r,o,n,u),y=p.getOverlapCorner(r,o,It(n),g);t.set(i,[f,y])}return t}getExposedOverlap(t){var e;if(1==this.overlaps.length)return t;let i=Ht(t),s=this.getParent(t);i.shift=null!==(e=i.shift)&&void 0!==e?e:{x:0,y:0};for(let e of this.overlaps)if(e!=t){let t=this.getParent(e),n=i.ox+i.shift.x,r=i.oy+i.shift.y;t.c[0].e==s.c[0].e&&(t.ox<s.ox&&(i.ox=n-(i.shift.x=Math.max(i.shift.x,t.ox))),t.oy<s.oy&&(i.oy=r-(i.shift.y=Math.max(i.shift.y,t.oy)))),t.c[2].e==s.c[2].e&&(t.ox<s.ox&&(i.ox=s.ox-Math.max(t.ox,s.ox-n)-i.shift.x),t.oy<s.oy&&(i.oy=s.oy-Math.max(t.oy,s.oy-r)-i.shift.y))}return i}getParent(t){return this.configuration.repository.structure[t.parent]}getSideConnectionTarget(t,e,i){let[s,n]=this._sideConnectionTarget.get(e);return s._x.gt(n._x)&&([s,n]=[n,s]),void 0===i?t._x.le(s._x)?s:t._x.ge(n._x)?n:null:0==i||3==i?s:n}toJSON(){let t={overlaps:this.overlaps,strategy:this.strategy},e=this.configuration.jidMap;if(e.size>0){t.overlaps=Ht(t.overlaps);for(let i of t.overlaps)for(let t of i.c)void 0!==t.e&&t.e>=0&&(t.e=e.get(t.e))}return t}}t([o],_.prototype,"intersectionCorners",null),t([o],_.prototype,"outCorners",null),t([o],_.prototype,"constraints",null),t([e],_.prototype,"_sideConnectionTarget",null);let x=class extends g{constructor(t,e){super(t,(t=>t),e,((t,e)=>e.disposed))}};x=t([e],x);let m=class extends g{constructor(t,e,i){super(t,e,i,((t,e)=>e.disposed))}};m=t([e],m);class w extends d{constructor(t){super(),this._oldStudio=null,this.mountTarget=t}get shouldDispose(){return super.shouldDispose||this.mountTarget instanceof w&&this.mountTarget.disposed}get $studio(){return this.disposed||!this.isActive?null:this.mountTarget instanceof w?this.mountTarget.$studio:this.mountTarget}mountEvents(){this.$studio!==this._oldStudio&&(this.$studio&&this.onMount(this.$studio),this._oldStudio&&this.onDismount(this._oldStudio),this._oldStudio=this.$studio)}onDispose(){this._oldStudio&&this.onDismount(this._oldStudio),super.onDispose()}get isActive(){return!0}static isActive(t){return t.isActive}onMount(t){}onDismount(t){}}t([e],w.prototype,"$studio",null),t([e],w.prototype,"mountEvents",null);let b=class extends d{constructor(t,e){for(super(t),this.node=new Map,this.edge=new p,this.path=new f((()=>this.node.values()),((t,e)=>new k(t,e))),this.nextId=0,this.jidMap=new Map,this.design=t;null==e?void 0:e.length;){let t=[],i=!1;for(let s of e)this.addEdge(s.n1,s.n2,s.length)?i=!0:t.push(s);if(!i)break;e=t}}onDispose(){Shrewd.terminate(this.edge),this.path.dispose()}get leaf(){var t=new Set;for(let e of this.node.values())1==e.degree&&t.add(e);return t}generateJID(){let t=Array.from(this.node.values()).sort(((t,e)=>t.id-e.id)),e=0;for(let i of t)this.jidMap.set(i.id,i.jid=e++)}dist(t,e){let i=this.path.get(t,e);return i?i.length:NaN}getOrAddNode(t){let e;return this.node.has(t)?e=this.node.get(t):(this.node.set(t,e=new C(this,t)),t>=this.nextId&&(this.nextId=t+1)),e}split(t){let e=this.getOrAddNode(this.nextId),{n1:i,n2:s}=t;return this.edge.delete(i,s),this.edge.set(e,i,new P(e,i,Math.ceil(t.length/2))),this.edge.set(e,s,new P(e,s,Math.max(Math.floor(t.length/2),1))),t.dispose(),e}deleteAndMerge(t){let e=this.getOrAddNode(this.nextId),{n1:i,n2:s,a1:n,a2:r}=t;this.edge.delete(i,s);for(let t of n){let s=t.n(i);this.edge.delete(s,i),this.edge.set(e,s,new P(e,s,t.length))}for(let t of r){let i=t.n(s);this.edge.delete(i,s),this.edge.set(e,i,new P(e,i,t.length))}return i.dispose(!0),s.dispose(!0),e}deleteAndJoin(t){let e=t.edges;if(2!=e.length)return void console.warn(`Incorrectly calling delete-and-join at [${t.id}].`);let i=e[0],s=e[1],n=i.n(t),r=s.n(t),o=new P(n,r,i.length+s.length);return this.edge.set(n,r,o),t.dispose(!0),o}addLeafAt(t,e){let i=this.nextId;return this.addEdge(t,i,e),this.node.get(i)}addEdge(t,e,i){let s=this.node.has(t),n=this.node.has(e);if(0!=this.node.size&&!s&&!n)return console.warn(`Adding edge (${t},${e}) disconnects the graph.`),!1;let r=this.getOrAddNode(t),o=this.getOrAddNode(e);if(this.edge.has(r,o))return this.edge.get(r,o).length=i,!1;if(s&&n)return console.warn(`Adding edge (${t},${e}) will cause circuit.`),!1;let h=new P(r,o,i);return this.edge.set(r,o,h),!0}distTriple(t,e,i){let s=this.dist(t,e),n=this.dist(t,i),r=this.dist(e,i),o=(s+n+r)/2;return{d1:o-r,d2:o-n,d3:o-s}}};t([e({renderer(t){for(let[e,i]of t)i.disposed&&t.delete(e);return t}})],b.prototype,"node",void 0),t([e({renderer(t){for(let e of t.firstKeys())e.disposed&&t.delete(e);return t}})],b.prototype,"edge",void 0),t([e],b.prototype,"leaf",null),b=t([e],b);class S{constructor(...t){void 0===t[1]&&(t=[t[0]._x,t[0]._y]),this._x=new v(t[0]),this._y=new v(t[1])}get x(){return this._x.value}set x(t){this._x=new v(t)}get y(){return this._y.value}set y(t){this._y=new v(t)}smp(){return this._x.smp(),this._y.smp(),this}eq(t){return!!t&&(this._x.eq(t._x)&&this._y.eq(t._y))}clone(){return new this.constructor(this._x,this._y)}toString(){return"("+this._x+", "+this._y+")"}toJSON(){return this.toString()}set(t,e=0){return t instanceof S?(this._x=new v(t._x),this._y=new v(t._y)):(this._x=new v(t),this._y=new v(e)),this}add(t){return new this.constructor(this._x.add(t._x),this._y.add(t._y)).smp()}addBy(t){return this._x.a(t._x),this._y.a(t._y),this.smp()}round(t=1){return this._x.d(t).r().m(t),this._y.d(t).r().m(t),this.smp()}range(t,e,i,s){return this._x.lt(t)&&(this._x=new v(t)),this._x.gt(e)&&(this._x=new v(e)),this._y.lt(i)&&(this._y=new v(i)),this._y.gt(s)&&(this._y=new v(s)),this}toIPoint(){return{x:this.x,y:this.y}}}class M extends w{constructor(t,e){if(super(t),this.id=M._id++,this.dragging=!1,this.edges=new x((()=>this.tree.edge.values()),(t=>new ot(this.TreeSheet,this.vertices.get(t.n1),this.vertices.get(t.n2),t))),this.rivers=new x((()=>[...this.tree.edge.values()].filter((t=>t.isRiver))),(t=>new lt(this.LayoutSheet,t))),this.vertices=new x((()=>this.tree.node.values()),(t=>new nt(this.TreeSheet,t))),this.flaps=new x((()=>this.tree.leaf),(t=>new it(this.LayoutSheet,t))),this.junctions=new f((()=>this.flaps.values()),((t,e)=>new ht(this.LayoutSheet,t,e))),this.stretches=new x((()=>this.teams.keys()),(t=>new A(this.LayoutSheet,t))),this.data=zt(ct.getSample(),e),this.data.tree.nodes.length<3)throw new Error("Invalid format.");this.options=new pt(this.data),this.history=new dt(this)}sortJEdge(){let t=this.edges.toJSON();if(0==t.length)return[];let e=new Set,i=[];for(;t.length;){let s=t.shift();0==e.size||e.has(s.n1)||e.has(s.n2)?(i.push(s),e.add(s.n1),e.add(s.n2)):t.push(s)}return i}get isActive(){return this instanceof E&&this.mountTarget.design==this}get patternNotFound(){return[...this.stretches.values()].some((t=>t.isTotallyValid&&null==t.pattern))}onDispose(){Shrewd.terminate(this.edges),Shrewd.terminate(this.vertices),Shrewd.terminate(this.rivers),Shrewd.terminate(this.flaps),Shrewd.terminate(this.stretches),this.junctions.dispose()}get validJunctions(){return[...this.junctions.values()].filter((t=>t.isValid))}get teams(){let t,e=new Set(this.activeJunctions),i=new Map;function s(i){if(e.has(i)){t.push(i),e.delete(i);for(let t of i.neighbors)s(t)}}for(;e.size>0;)t=[],s(e.values().next().value),t.sort(ht.sort),i.set(ht.createTeamId(t,(t=>t.node.id)),t);return i}get devices(){let t=[];for(let e of this.stretches.values())t.push(...e.devices);return t}get activeJunctions(){return this.validJunctions.filter((t=>!t.isCovered))}get junctionsByQuadrant(){return M.ToQuadrantMap(this.junctions.values())}get activeJunctionsByQuadrant(){return M.ToQuadrantMap(this.activeJunctions)}static ToQuadrantMap(t){let e=new Map;function i(t,i){let s=e.get(t);s||e.set(t,s=[]),s.push(i)}for(let e of t)i(e.q1,e),i(e.q2,e);return e}get stretchByQuadrant(){let t=new Map;for(let e of this.stretches.values())if(e.isActive)for(let i of e.junctions)t.set(i.q1,e),t.set(i.q2,e);return t}getStretchByQuadrant(t){var e;return null!==(e=this.stretchByQuadrant.get(t))&&void 0!==e?e:null}get flapsById(){let t=new Map;for(let e of this.flaps.values())t.set(e.node.id,e);return t}get openAnchors(){let t=new Map;for(let e of this.activeStretches){let i=e.fx*e.fy;for(let s of e.pattern.devices)for(let e of s.openAnchors){let s=i+","+(e.x-i*e.y),n=t.get(s);n||t.set(s,n=[]),n.push(e)}}return t}get activeStretches(){return[...this.stretches.values()].filter((t=>t.isActive&&!!t.pattern))}}M._id=0,t([e],M.prototype,"dragging",void 0),t([e],M.prototype,"isActive",null),t([e],M.prototype,"patternNotFound",null),t([e],M.prototype,"validJunctions",null),t([e],M.prototype,"teams",null),t([e],M.prototype,"devices",null),t([e],M.prototype,"activeJunctions",null),t([e],M.prototype,"junctionsByQuadrant",null),t([e],M.prototype,"activeJunctionsByQuadrant",null),t([e],M.prototype,"stretchByQuadrant",null),t([e],M.prototype,"flapsById",null),t([e],M.prototype,"openAnchors",null),t([e],M.prototype,"activeStretches",null);class q extends w{constructor(t){super(t),this.sheet=t}get design(){return this.sheet.design}}let I=class extends w{constructor(t,e,...i){super(t),this._activeControlCache=[],this._independentRect=new Et(T.ZERO,T.ZERO),this.margin=0,this.scroll={x:0,y:0},this.width=e.width,this.height=e.height,this.scale=Math.max(e.scale,this.getMinScale()),this._controlMaps=i,this.view=new V(this)}get controls(){var t=[];for(let e of this._controlMaps)t.push(...e());return t}get activeControls(){return this.design.dragging||(this._activeControlCache=this.controls.filter((t=>w.isActive(t)))),this._activeControlCache}constraint(t,e){return t.range(-e.x,this.width-e.x,-e.y,this.height-e.y)}getMinScale(){var t,e;return Math.ceil(null!==(e=null===(t=this.$studio)||void 0===t?void 0:t.$display.getAutoScale())&&void 0!==e?e:10)}get design(){return this.mountTarget}get isActive(){return this.design.sheet==this}get displayScale(){return this.$studio?this.$studio.$display.scale:1}toJSON(){return{width:this.width,height:this.height,scale:this.scale}}get size(){return Math.max(this.width,this.height)}contains(t){return 0<=t.x&&t.x<=this.width&&0<=t.y&&t.y<=this.height}get independents(){return this.controls.filter((t=>t instanceof U))}_getIndependentRect(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,s=Number.NEGATIVE_INFINITY;for(let n of this.independents){let r=n.location;r.x<t&&(t=r.x),r.x>i&&(i=r.x),r.y<e&&(e=r.y),r.y>s&&(s=r.y)}this._independentRect=new Et(new T(t,e),new T(i,s))}getMargin(){if(!this.isActive||!this.design.isActive)return;let t=this.controls.filter((t=>t instanceof F)),e=t.length?Math.max(...t.map((t=>t.view.overflow))):0;setTimeout((()=>this.margin=e),0)}};t([e],I.prototype,"controls",null),t([e],I.prototype,"activeControls",null),t([s({validator(t){let e=t>=8&&t>=this._independentRect.width,i=t-this._independentRect.right;if(e&&i<0)for(let t of this.independents)t.location.x+=i;return e}})],I.prototype,"width",void 0),t([s({validator(t){let e=t>=8&&t>=this._independentRect.height,i=t-this._independentRect.top;if(e&&i<0)for(let t of this.independents)t.location.y+=i;return e}})],I.prototype,"height",void 0),t([s({validator(t){return t>=Math.min(10,this.getMinScale())}})],I.prototype,"scale",void 0),t([e],I.prototype,"isActive",null),t([e],I.prototype,"displayScale",null),t([e],I.prototype,"size",null),t([e],I.prototype,"independents",null),t([e],I.prototype,"_getIndependentRect",null),t([e],I.prototype,"margin",void 0),t([e],I.prototype,"getMargin",null),t([e],I.prototype,"scroll",void 0),I=t([e],I);class N extends w{constructor(){super(...arguments),this._paths=[]}draw(){this.mountEvents(),this.$studio&&(this.$studio.$display.render(),this.render())}$addItem(t,e){this._paths.push([t,e])}onMount(t){for(let[e,i]of this._paths)t.$display.project.layers[e].addChild(i)}onDismount(t){for(let[t,e]of this._paths)e.remove()}contains(t){return!1}}t([e],N.prototype,"draw",null);let C=class extends d{constructor(t,e){super(t),this.name="",this.tree=t,this.id=e}get shouldDispose(){return super.shouldDispose||this.tree.disposed}dispose(t=!1){if(t||1==this.degree)super.dispose();else{if(2==this.degree)return this.tree.deleteAndJoin(this);1!=this.degree&&console.warn(`Node [${this.name?this.name:this.id}] is not a leaf.`)}}addLeaf(t){return this.tree.addLeafAt(this.id,t)}get design(){return this.tree.design}get edges(){let t=this.tree.edge.get(this);return t?Array.from(t.values()):[]}get degree(){return this.edges.length}get firstEdge(){return this.edges[0]}get radius(){return 1==this.degree?this.edges[0].length:NaN}};t([s],C.prototype,"name",void 0),t([e],C.prototype,"edges",null),t([e],C.prototype,"degree",null),t([e],C.prototype,"firstEdge",null),t([e],C.prototype,"radius",null),C=t([e],C);let P=class extends d{constructor(t,e,i){super(),this._n1=t,this._n2=e,this.length=i}get design(){return this.n1.design}get shouldDispose(){return super.shouldDispose||this._n1.disposed||this._n2.disposed}get isRiver(){return this.g1.length>1&&this.g2.length>1}adjacentEdges(t){return t.edges.filter((t=>t!=this))}get a1(){return this.adjacentEdges(this._n1)}get a2(){return this.adjacentEdges(this._n2)}group(t,e){let i=[t];for(let s of e)i.push(...s.g(t));return i}get g1(){return this.group(this._n1,this.a1)}get g2(){return this.group(this._n2,this.a2)}g(t){return t==this._n1?this.g2:this.g1}get l1(){return this.g1.filter((t=>1==t.degree))}get l2(){return this.g2.filter((t=>1==t.degree))}get t1(){return this.a1.map((t=>t.t(this._n1)+t.length)).reduce(((t,e)=>t+e),0)}get t2(){return this.a2.map((t=>t.t(this._n2)+t.length)).reduce(((t,e)=>t+e),0)}t(t){return t==this._n1?this.t2:this.t1}get p1(){return Math.max(...this.l1.map((t=>t.tree.dist(t,this.n1))))}get p2(){return Math.max(...this.l2.map((t=>t.tree.dist(t,this.n2))))}get wrapSide(){return this.isRiver?this.p1>this.p2?2:this.p1<this.p2?1:this.t1>this.t2?2:this.t1<this.t2||this.g1.length>this.g2.length?1:this.g1.length<this.g2.length?2:0:0}get n1(){return this._n1}get n2(){return this._n2}n(t){return t==this._n1?this._n2:this._n1}};t([s({validator:t=>t>0})],P.prototype,"length",void 0),t([e],P.prototype,"isRiver",null),t([e],P.prototype,"a1",null),t([e],P.prototype,"a2",null),t([e],P.prototype,"g1",null),t([e],P.prototype,"g2",null),t([e],P.prototype,"l1",null),t([e],P.prototype,"l2",null),t([e],P.prototype,"t1",null),t([e],P.prototype,"t2",null),t([e],P.prototype,"p1",null),t([e],P.prototype,"p2",null),t([e],P.prototype,"wrapSide",null),P=t([e],P);let k=class extends d{constructor(t,e){super(),this._n1=t,this._n2=e}get shouldDispose(){return super.shouldDispose||this._n1.disposed||this._n2.disposed}get edges(){let t=[],e=this._n1,i=!0;for(;e!=this._n2&&i;){i=!1;for(let s of e.edges)if(s.g(e).includes(this._n2)){i=!0,t.push(s),e=s.n(e);break}}return t}get length(){return this.edges.reduce(((t,e)=>t+e.length),0)}};t([e],k.prototype,"edges",null),t([e],k.prototype,"length",null),k=t([e],k);class T extends S{static get ZERO(){return new T(0,0)}constructor(...t){void 0===t[1]?super(t[0].x,t[0].y):super(...t)}dist(t){return this.sub(t).length}paramDist(t){return Math.max(Math.abs(t.x-this.x),Math.abs(t.y-this.y))}sub(t){return t instanceof R?new T(this._x.sub(t._x),this._y.sub(t._y)).smp():t instanceof T?new R(this._x.sub(t._x),this._y.sub(t._y)).smp():new R(this._x.sub(t.x),this._y.sub(t.y)).smp()}subBy(t){return this._x.s(t.x),this._y.s(t.y),this}diagonalXRange(t,e,i){this._x.lt(t)&&this.setDiagonalX(t,i),this._x.gt(e)&&this.setDiagonalX(e,i)}toPaper(){return new paper.Point(this.x,this.y)}setDiagonalX(t,e){var i=this._x.sub(t);this._x.s(i),e?this._y.a(i):this._y.s(i)}eq(t){return t instanceof T||!t?super.eq(t):this.x==t.x&&this.y==t.y}get isIntegral(){return this._x.$denominator===y&&this._y.$denominator===y}transform(t,e){return new T(this._x.mul(t),this._y.mul(e))}}class R extends S{static get ZERO(){return new R(0,0)}constructor(...t){void 0===t[1]?super(t[0].x,t[0].y):super(...t)}get length(){return Math.sqrt(this.dot(this))}get slope(){return this._y.div(this._x)}rotate90(){return new R(this._y.neg,this._x)}normalize(){return this.scale(new v(this.length).inv)}scale(t,e){return t instanceof S?this.scale(t._x,t._y):(e||(e=t),new R(this._x.mul(t),this._y.mul(e)).smp())}dot(t){return this._x.mul(t._x).a(this._y.mul(t._y)).value}get neg(){return new R(this._x.neg,this._y.neg)}get angle(){return Math.atan2(this.y,this.x)}reduce(){let[t,e]=[this._x.$numerator,this._y.$numerator],[i,s]=[this._x.$denominator,this._y.$denominator],[n,r]=Ft.reduce(t*s,e*i);return new R(Number(n),Number(r))}doubleAngle(t=1){let{x:e,y:i}=this.reduce();return[e,i]=Ft.reduce(e*e-i*i,2*e*i),new R(t*e,t*i)}parallel(t){return this._x.mul(t._y).eq(this._y.mul(t._x))}static bisector(t,e){let[i,s]=Ft.reduce(t.x,t.y),[n,r]=Ft.reduce(e.x,e.y),o=Math.sqrt(i*i+s*s),h=Math.sqrt(n*n+r*r);return new R(i*h+n*o,s*h+r*o)}}let E=class extends M{constructor(t,e){super(t,e),this.LayoutSheet=new I(this,this.data.layout.sheet,(()=>this.flaps.values()),(()=>this.rivers.values()),(()=>this.stretches.values()),(()=>this.devices)),this.TreeSheet=new I(this,this.data.tree.sheet,(()=>this.edges.values()),(()=>this.vertices.values())),this.title=this.data.title,this.fullscreen=this.data.fullscreen,this.description=this.data.description,this.mode=this.data.mode,this.tree=new b(this,this.data.tree.edges)}get sheet(){return"layout"==this.mode?this.LayoutSheet:this.TreeSheet}get design(){return this}toJSON(){this.tree.generateJID();let t={title:this.title,description:this.description,fullscreen:this.fullscreen,version:ct.current,mode:this.mode,layout:{sheet:this.LayoutSheet.toJSON(),flaps:this.flaps.toJSON(),stretches:this.stretches.toJSON()},tree:{sheet:this.TreeSheet.toJSON(),nodes:this.vertices.toJSON(),edges:this.sortJEdge()}};return this.tree.jidMap.clear(),t}deleteVertices(t){this.history.takeAction((()=>{let e=t.concat().sort(((t,e)=>t.node.degree-e.node.degree));for(;this.vertices.size>3;){let t=e.find((t=>1==t.node.degree));if(!t)break;t.node.dispose(),e.splice(e.indexOf(t),1),Shrewd.commit()}}))}deleteFlaps(t){this.history.takeAction((()=>{for(let e of t){if(3==this.vertices.size)break;e.node.dispose(),Shrewd.commit()}}))}clearCPSelection(){for(let t of this.LayoutSheet.controls)t.selected=!1}clearTreeSelection(){for(let t of this.TreeSheet.controls)t.selected=!1}flapToVertex(t){this.clearTreeSelection();for(let e of t){let t=this.vertices.get(e.node);t&&(t.selected=!0)}this.mode="tree"}vertexToFlap(t){this.clearCPSelection();for(let e of t){let t=this.flaps.get(e.node);t&&(t.selected=!0)}this.mode="layout"}riverToEdge(t){this.clearTreeSelection();let e=this.edges.get(t.edge);e&&(e.selected=!0),this.mode="tree"}edgeToRiver(t){this.clearCPSelection();let e=t.edge;if(e.isRiver){let t=this.rivers.get(e);t&&(t.selected=!0)}else{let t=1==e.n1.degree?e.n1:e.n2,i=this.flaps.get(t);i&&(i.selected=!0)}this.mode="layout"}};t([e],E.prototype,"fullscreen",void 0),t([e],E.prototype,"mode",void 0),t([s],E.prototype,"description",void 0),t([s],E.prototype,"title",void 0),t([e],E.prototype,"sheet",null),E=t([e],E);class D extends q{constructor(){super(...arguments),this.selected=!1}selectableWith(t){return!1}get dragSelectAnchor(){return null}toggle(){this.selected=!this.selected}contains(t){return!1}static isDragSelectable(t){return null!=t.dragSelectAnchor}}var O;t([e],D.prototype,"selected",void 0);let j=O=class extends q{constructor(t,e,i){super(t),this.flap=e,this.q=i,this.qv=O.QV[i],this.sv=O.SV[i],this.pv=O.SV[(i+1)%4],this.fx=0==this.q||3==this.q?1:-1,this.fy=0==this.q||1==this.q?1:-1}getOverlapCorner(t,e,i,s){var n,r,o,h;let l=this.flap.radius+s,a=null!==(r=null===(n=t.shift)||void 0===n?void 0:n.x)&&void 0!==r?r:0,d=null!==(h=null===(o=t.shift)||void 0===o?void 0:o.y)&&void 0!==h?h:0;return this.flap.node.id!=e.c[0].e&&(a=e.ox-(t.ox+a),d=e.oy-(t.oy+d)),new T(this.x(l-(3==i?0:t.ox)-a),this.y(l-(1==i?0:t.oy)-d))}makeContour(t){let e,i=this.flap.radius+t,s=this.sv.scale(i),n=this.getStart(i),r=this.point.add(s.rotate90()),o=this.pattern;if(o){let t=o.linesForTracing[this.q].concat(),s=o.stretch.junctions,h=this.findNextDelta(s,!1),l=new Set,a=this.findLead(s,i,t,l),d=a?this.findNextDelta(s,!0):void 0;e=kt.create(t,null!=a?a:n,this.pv,l,null!=h?h:new Nt(r,this.pv),d),d&&this.outside(e[0],i,this.q%2!=1)&&e.unshift(this.q%2?d.yIntersection(this.y(i)):d.xIntersection(this.x(i))),h&&this.outside(e[e.length-1],i,this.q%2==1)&&e.push(this.q%2?h.xIntersection(this.x(i)):h.yIntersection(this.y(i)))}else e=[n,this.point.add(this.qv.scale(i))];return e.map((t=>t.toPaper()))}outside(t,e,i){return i?t.x*this.fx>this.x(e)*this.fx:t.y*this.fy>this.y(e)*this.fy}getStart(t){return this.point.add(this.sv.scale(t))}y(t){return this.point.y+this.fy*t}x(t){return this.point.x+this.fx*t}findNextDelta(t,e){let i=this.findJoinNextQ(t,e,!0);if(!i)return;let{joinQ:s,nextQ:n,mode:r}=i,{d1:o,d2:h}=this.design.tree.distTriple(this.flap.node,n.flap.node,s.flap.node),l=r?new T(n.x(h),this.y(o)):new T(this.x(o),n.y(h));return new Nt(l,this.qv)}findJoinNextQ(t,e,i){if(1==t.length)return;let s,n=!!(this.q%2)==e,r=n?"oy":"ox",o=ht.findMinMax(t.filter((t=>t.q1==this||t.q2==this)),r,-1),h=o.q1==this?o.q2:o.q1;if(1!=h.activeJunctions.length){if(i){let t=h.activeJunctions.concat().sort(((t,e)=>t[r]-e[r]));if(s=t[t.indexOf(o)+1],!s)return}else if(s=ht.findMinMax(h.activeJunctions,r,1),s==o)return;return{joinQ:h,nextQ:s.q1==h?s.q2:s.q1,mode:n}}}findLead(t,e,i,s){var n;let r=this.findJoinNextQ(t,!0,!1);if(!r)return;let{joinQ:o,nextQ:h}=r,l=this.design.junctions.get(this.flap,h.flap).status==vt.tooFar,a=this.design.tree.distTriple(this.flap.node,h.flap.node,o.flap.node);if(e<=a.d1&&(l||e!=a.d1))return;let d=e-a.d1+a.d2,c=this.q%2?new T(h.x(d),this.y(e)):new T(this.x(e),h.y(d));return s.add(c.toString()),null!==(n=h.findLead(t,d,i,s))&&void 0!==n?n:h.getStart(d)}getOverriddenPath(t){let e=[];if(this.pattern)return e;let i=this.flap.radius+t;for(let[t,s]of this.coveredJunctions){let{ox:n,oy:r}=t,o=this.point.add(this.qv.scale(i));for(let t of s){let e=t.sub(o);n=Math.min(-e.x*this.fx,n),r=Math.min(-e.y*this.fy,r)}let h=new R(n*this.fx,r*this.fy);e.push(new paper.Path.Rectangle(o.toPaper(),o.sub(h).toPaper()))}return e}get pattern(){let t=this.design.getStretchByQuadrant(this);return t?t.pattern:null}get corner(){let t=this.flap.radius;return this.point.add(this.qv.scale(t))}get junctions(){var t;return null!==(t=this.design.junctionsByQuadrant.get(this))&&void 0!==t?t:[]}get coveredJunctions(){return this.junctions.filter((t=>t.isValid&&t.isCovered)).map((t=>{let e=t.q1==this?t.q2:t.q1;return[t,t.coveredBy.map((t=>t.q1==e?t.q2.point:t.q1.point))]}))}get point(){return this.flap.points[this.q]}get activeJunctions(){let t=this.design.activeJunctionsByQuadrant.get(this);return t||[]}static transform(t,e,i){return e<0&&(t+=t%2?3:1),i<0&&(t+=t%2?1:3),t%4}getBaseRectangle(t){let e=this.flap.radius;return new Et(new T(this.x(e),this.y(e)),new T(this.x(e-t.ox),this.y(e-t.oy)))}debug(t=0){i=!0,console.log(this.makeContour(t).map((t=>t.toString()))),i=!1}};j.QV=[new R(1,1),new R(-1,1),new R(-1,-1),new R(1,-1)],j.SV=[new R(1,0),new R(0,1),new R(-1,0),new R(0,-1)],t([e],j.prototype,"pattern",null),t([e],j.prototype,"corner",null),t([e],j.prototype,"junctions",null),t([e],j.prototype,"coveredJunctions",null),t([e],j.prototype,"point",null),t([e],j.prototype,"activeJunctions",null),j=O=t([e],j);let A=class extends D{constructor(t,e){super(t),this._repoCache=new Map,this.signature=e}get type(){return"Stretch"}get junctions(){var t;let e=null!==(t=this.design.teams.get(this.signature))&&void 0!==t?t:[];if(this.junctionCache&&this.junctionCache.length==e.length){for(let t in e)if(e[t]!=this.junctionCache[t])return this.junctionCache=e;return this.junctionCache}return this.junctionCache=e}get flaps(){let t=new Set;for(let e of this.junctions)t.add(e.f1),t.add(e.f2);return Array.from(t)}get origin(){var t,e,i;return null!==(i=null===(e=null===(t=this.junctions[0])||void 0===t?void 0:t.q1)||void 0===e?void 0:e.point)&&void 0!==i?i:T.ZERO}get repository(){if(!this.isValid)return null;let t,e=this.structureSignature;if(this._repoCache.has(e))t=this._repoCache.get(e);else{let i=this.design.options.get("stretch",this.signature);t=new $t(this,e,i)}return this.design.dragging||this._repoCache.clear(),this._repoCache.set(e,t),t}get fx(){var t,e;return null!==(e=null===(t=this.junctions[0])||void 0===t?void 0:t.fx)&&void 0!==e?e:1}get fy(){var t,e;return null!==(e=null===(t=this.junctions[0])||void 0===t?void 0:t.fy)&&void 0!==e?e:1}get shouldDispose(){return super.shouldDispose||!this.isActive&&!this.design.dragging}get isActive(){return this.design.teams.has(this.signature)}get pattern(){var t,e,i;return null!==(i=null===(e=null===(t=this.repository)||void 0===t?void 0:t.entry)||void 0===e?void 0:e.entry)&&void 0!==i?i:null}get isValid(){return this.junctions.every((t=>t.status==vt.overlap))}get isTotallyValid(){if(!this.isActive)return!1;for(let t=0;t<this.flaps.length;t++)for(let e=t+1;e<this.flaps.length;e++){if(this.design.junctions.get(this.flaps[t],this.flaps[e]).status==vt.tooClose)return!1}return!0}get structureSignature(){return this.isValid?JSON.stringify(this.junctions.map((t=>{let e=t.toJSON(),i=e.c;return t.fx!=this.fx&&(e.c=[i[2],i[3],i[0],i[1]]),e}))):""}get devices(){return this.pattern?this.pattern.devices:[]}toJSON(){var t,e,i,s;return{id:ht.createTeamId(this.junctions,(t=>t.node.jid)),configuration:null!==(e=null===(t=this.pattern)||void 0===t?void 0:t.configuration.toJSON())&&void 0!==e?e:void 0,pattern:null!==(s=null===(i=this.pattern)||void 0===i?void 0:i.toJSON())&&void 0!==s?s:void 0}}};t([e],A.prototype,"junctions",null),t([e],A.prototype,"flaps",null),t([e],A.prototype,"repository",null),t([e],A.prototype,"isActive",null),t([e],A.prototype,"pattern",null),t([e],A.prototype,"isValid",null),t([e],A.prototype,"isTotallyValid",null),t([e],A.prototype,"structureSignature",null),A=t([e],A);let J=class extends q{constructor(t,e){super(t.sheet),this.configuration=t,this.devices=e.devices.map(((e,i)=>new Ot(this,t.partitions[i],e))),this.gadgets=this.devices.reduce(((t,e)=>t.concat(e.gadgets)),[]),this.signature=JSON.stringify(e)}static getSignature(t){let e=t.devices;t.devices=t.devices.map((t=>((t=Ht(t)).gadgets.forEach((t=>jt.simplify(t))),t.offset=void 0,t)));let i=JSON.stringify(t);return t.devices=e,i}get shouldDispose(){return super.shouldDispose||this.configuration.disposed}get isActive(){return this.configuration.isActive&&this.configuration.entry==this}get linesForTracing(){if(!this.isActive)return Mt((t=>[]));let t=this.configuration.repository.stretch.junctions[0].direction,{fx:e,fy:i}=this.stretch;return Mt((s=>{let n=[];if(t%2!=s%2)return n;for(let t of this.devices){let r=j.QV[s].scale(this.design.sheet.size);n.push(...t.ridges),n.push(...t.getConnectionRidges(!0));for(let[o,h,l]of t.partition.outCorners){let a=t.anchors[h][l];if(o.type==mt.side||o.type==mt.flap&&s!=j.transform(l,e,i)||o.type==mt.internal&&s!=j.transform(o.q,e,i))n.push(new Nt(a,a.add(r)));else if(o.type==mt.intersection){let e=t.partition.overlaps[h].c.find((t=>t.type==mt.flap)).q,i=t.partition.getSideConnectionTarget(a,o,e);i&&n.push(new Nt(a,i))}else n.push(new Nt(a,this.getConnectionTarget(o)))}}return Nt.distinct(n)}))}toJSON(){return{devices:this.devices.map((t=>t.toJSON()))}}get selected(){return this.devices.some((t=>t.selected))}get stretch(){return this.configuration.repository.stretch}getConnectionTarget(t){if(t.e>=0)return this.design.flapsById.get(t.e).points[t.q];{let[e,i]=this.configuration.overlapMap.get(t.e);return this.devices[e].anchors[i][t.q]}}};t([e],J.prototype,"isActive",null),t([e],J.prototype,"linesForTracing",null),J=t([e],J);class $ extends q{constructor(){super(...arguments),this.index=0,this._prototypeCache=[],this._cache=[]}get _prototypes(){if(!this.generator)return this._prototypeCache;if(this.design.dragging)return this.buildFirst(),this._prototypeCache.concat();0==this._cache.length&&this.buildFirst();for(let t of this.generator)this._prototypeCache.push(t);return delete this.generator,this._prototypeCache}buildFirst(){let t=this.generator.next();if(!t.done)try{this._cache[0]=this.builder(t.value),this._prototypeCache.push(t.value)}catch(t){console.log("Incompatible old version.")}}get entry(){let t=this._prototypes,e=this.index;return 0==t.length?null:this._cache[e]=this._cache[e]||this.builder(t[e])}move(t=1){let e=this.index,i=this._prototypes.length;this.index=(this.index+t+i)%i,this.onMove(this.index,e),Shrewd.commit()}get size(){return this._prototypes.length}}t([s],$.prototype,"index",void 0),t([e],$.prototype,"_prototypes",null),t([e],$.prototype,"entry",null);class L extends N{constructor(t){super(t),this.control=t}drawSelection(){this.renderSelection(this.control.selected)}get overflow(){return 0}}t([e],L.prototype,"drawSelection",null);let B=class extends N{constructor(t){super(t),this.visible=!1,this.$addItem(xt.drag,this._rectangle=new paper.Path.Rectangle(bt.selection))}contains(t){return this._rectangle.contains(t)}render(){if(this._rectangle.visible=this.visible){let t=new paper.Path.Rectangle({from:this.down,to:this.now});this._rectangle.set({segments:t.segments})}}};t([e],B.prototype,"visible",void 0),t([e],B.prototype,"down",void 0),t([e],B.prototype,"now",void 0),B=t([e],B);let V=class extends N{constructor(t){super(t),this._sheet=t,this._border=new paper.Path.Rectangle({point:[0,0],size:[0,0],strokeWidth:3}),this.$addItem(xt.sheet,this._border),this._grid=new paper.CompoundPath(bt.sheet),this.$addItem(xt.sheet,this._grid)}contains(t){return this._border.contains(t)}render(){var t;if(!this.$studio)return;let e=this._sheet.width,i=this._sheet.height;Wt.setRectangleSize(this._border,e,i),this._grid.visible=null===(t=this.$studio)||void 0===t?void 0:t.$display.settings.showGrid,this._grid.removeChildren();for(let t=1;t<i;t++)Wt.addLine(this._grid,new paper.Point(0,t),new paper.Point(e,t));for(let t=1;t<e;t++)Wt.addLine(this._grid,new paper.Point(t,0),new paper.Point(t,i))}};V=t([e],V);class F extends D{contains(t){return this.view.draw(),this.view.contains(t)}}let W=class extends ${constructor(t,e,i){super(t.sheet),this.repository=t,this.seed=i,i&&(this.seedSignature=J.getSignature(i));let s=[],n=new Map,r=-1;for(let[t,i]of e.partitions.entries())for(let[e,o]of i.overlaps.entries())s.push(o),n.set(r--,[t,e]);this.overlaps=s,this.overlapMap=n,this.partitions=e.partitions.map((t=>new _(this,t))),this.generator=this.generate()}get isActive(){return this.repository.isActive&&this.repository.entry==this}builder(t){return new J(this,t)}*generate(){this.seed&&(yield this.seed);yield*Bt.filter(this.search([]),(t=>!this.seedSignature||this.seedSignature!=J.getSignature(t)))}*search(t,e=0){if(e==this.partitions.length){let e=this.makePattern(Ht(t));e&&(yield e)}else for(let i of this.partitions[e].generate())t.push(i),yield*this.search(t,e+1),t.pop()}makePattern(t){t.forEach((t=>t.gadgets=t.gadgets.map((t=>jt.instantiate(t)))));let e=t,i=this.repository.structure;if(1==i.length){let t=i[0].sx;if(1==e.length)return e[0].offset=Math.floor((t-e[0].gadgets[0].sx)/2),{devices:e};if(2==e.length){let[i,s]=e.map((t=>t.gadgets[0])),n=this.overlaps[0].c[2],r=this.overlaps[1].c[0],o=i.sx+s.rx(n.q,2),h=s.sx+i.rx(r.q,0);return o>t||h>t?null:(e[1].offset=t-h,{devices:e})}}if(2==i.length&&1==this.partitions.length){let[t,i]=this.overlaps,[s,n]=[t,i].map((t=>this.repository.structure[t.parent])),r=s.c[0].e==n.c[0].e,o=e[0].gadgets;return o[0].sx>s.sx||o[1].sx>n.sx?null:(r||(e[0].offset=s.sx-o[0].sx),{devices:e})}if(2==i.length&&2==this.partitions.length){let[t,i]=e.map((t=>t.gadgets[0])),[s,n]=this.overlaps,r=s.c[0].e>=0&&s.c[2].e>=0;r&&([t,i]=[i,t],[s,n]=[n,s]);let[o,h]=[s,n].map((t=>this.repository.structure[t.parent])),l=s.c[0].e<0,a=l?0:2,d=s.c[a].q,c=o.sx,u=t.sx,p=t.setupConnectionSlack(i,a,d);c-=Math.ceil(i.rx(d,a))+p;let g=l?[null!=p?p:0,0]:[c-u,h.sx-i.sx];return r&&g.reverse(),u>c?null:i.contains(this.getRelativeDelta(o,h,i))?null:(e.forEach(((t,e)=>t.offset=g[e])),{devices:e})}return null}getRelativeDelta(t,e,i){let s=t.c[0].e==e.c[0].e,n=l.getMaxIntersectionDistance(this.design.tree,t,e,s);e.ox>t.ox&&([t,e]=[e,t]);let r={x:n-e.ox,y:n-t.oy};return s||(r.x=i.sx-r.x,r.y=i.sy-r.y),new T(r)}onMove(){this.repository.stretch.selected=!this.entry.selected}toJSON(){return{partitions:this.partitions.map((t=>t.toJSON()))}}get jidMap(){return this.design.tree.jidMap}};t([e],W.prototype,"isActive",null),W=t([e],W);class z extends L{get overflow(){if(!this.$studio)return 0;this.render();let t=0,e=this._label.bounds,i=this.$studio.$display.scale*this.control.sheet.width,s=e.x,n=e.x+e.width;return s<0&&(t=-s),n>i&&(t=Math.max(t,n-i)),Math.ceil(t)}}var H;t([e],z.prototype,"overflow",null);let G=H=class extends N{constructor(t){super(t),this._junction=t,this.$addItem(xt.junction,this._shade=new paper.CompoundPath(bt.junction))}render(){if(this._shade.visible=this._junction.status==vt.tooClose){let t=this._junction.f1,e=this._junction.f2;this._shade.removeChildren();let i=this._junction.$treeDistance-(t.radius+e.radius);if(0==i)this._shade.addChild(t.view.circle.intersect(e.view.circle)),this._shade.strokeWidth=H.widthForArea(this._shade.area);else{let s=t.view.makeRectangle(i),n=e.view.makeRectangle(i);this._shade.addChild(t.view.circle.intersect(n)),this._shade.addChild(e.view.circle.intersect(s)),this._shade.strokeWidth=H.widthForArea(this._shade.area)}}}static widthForArea(t){return t<.25?4:t<.5?3:t<1?2:1}};G=H=t([e],G);let Q=class extends L{constructor(t){super(t),this.components=new x((()=>this.info.components),(t=>new K(this,t))),this.$addItem(xt.shade,this._shade=new paper.CompoundPath(bt.shade)),this.$addItem(xt.hinge,this._hinge=new paper.CompoundPath(bt.hinge)),this.$addItem(xt.ridge,this._ridge=new paper.CompoundPath(bt.ridge)),this.boundary=new paper.CompoundPath({})}contains(t){return this.control.sheet.view.contains(t)&&this._shade.contains(t)}get info(){if(this.disposed)return{adjacent:[],length:0,components:[]};let t,e,i=this.control.edge;return 0==i.wrapSide?(e=this.toComponents(i.l1,i.n1).concat(this.toComponents(i.l2,i.n2)),t=i.a1.concat(i.a2)):2==i.wrapSide?(e=this.toComponents(i.l2,i.n2),t=i.a2):(e=this.toComponents(i.l1,i.n1),t=i.a1),{adjacent:t,length:i.length,components:e}}toComponents(t,e){return t.map((t=>t.id+","+e.id))}get design(){return this.control.sheet.design}onDispose(){Shrewd.terminate(this.components),super.onDispose()}get closure(){let t=new paper.PathItem;if(this.disposed)return t;for(let e of this.components.values()){let i=e.contour;t=t.isEmpty()?i:t.unite(i,{insert:!1})}return t}get actualPath(){var t;let{adjacent:e}=this.info,i=this.control.sheet.design,s=this.closure;if(this.disposed)return s;for(let n of e)if(n.isRiver){let e=i.rivers.get(n);for(let i of null!==(t=e.view.closure.children)&&void 0!==t?t:[e.view.closure])s=s.subtract(i,{insert:!1})}else{let t=i.flaps.get(1==n.n1.degree?n.n1:n.n2);t.view.renderHinge(),s=s.subtract(t.view.hinge,{insert:!1})}return s.reorient(!1,!0)}render(){Wt.replaceContent(this.boundary,this.closure,!0),Wt.replaceContent(this._shade,this.actualPath,!1),Wt.replaceContent(this._hinge,this.actualPath,!1),this.renderRidge()}get corners(){var t;if(this.disposed)return[];let e=this.actualPath,i=(null!==(t=e.children)&&void 0!==t?t:[e]).map((t=>t.segments.map((t=>new T(t.point)))));if(0==i[0].length)return[];let{paths:s,map:n}=Pt.collect(i),r=[];for(let t of s){let e=t.length,i=t[e-1],s=t[0],o=s.sub(i);for(let h=0;h<e;h++){let l=t[(h+1)%e],a=l.sub(s);if(0==o.dot(a)&&o.rotate90().dot(a)>0){let t=new R(Math.sign(a.x)-Math.sign(o.x),Math.sign(a.y)-Math.sign(o.y)).scale(this.control.length),e=s.add(t);r.push([s,e,n.has(e.toString())])}i=s,s=l,o=a}}return r}renderRidge(){var t;this._ridge.removeChildren();for(let[e,i,s]of this.corners){let n=new Nt(e,i),r=n.slope.value,o=r+","+(e.x-r*e.y),h=(null!==(t=this.control.sheet.design.openAnchors.get(o))&&void 0!==t?t:[]).find((t=>n.contains(t,!0)));h?Wt.addLine(this._ridge,e,h):s&&Wt.addLine(this._ridge,e,i)}}renderSelection(t){this._shade.visible=t}};t([e],Q.prototype,"info",null),t([e],Q.prototype,"closure",null),t([e],Q.prototype,"actualPath",null),t([e],Q.prototype,"corners",null),Q=t([e],Q);let K=class extends d{constructor(t,e){super(t),this.view=t,this.key=e;let[i,s]=e.split(",").map((t=>Number(t)));this.flap=t.design.flapsById.get(i),this.node=t.design.tree.node.get(s)}get shouldDispose(){return super.shouldDispose||this.flap.disposed||!this.view.info.components.some((t=>t==this.key))}onDispose(){delete this.flap,delete this.node}get distance(){if(this.disposed)return 0;let{design:t,info:e}=this.view,i=this.flap;return t.tree.dist(i.node,this.node)-i.radius+e.length}get contour(){return this.flap.view.draw(),this.flap.view.makeContour(this.distance)}};t([e],K.prototype,"distance",null),t([e],K.prototype,"contour",null),K=t([e],K);class Y extends F{constructor(){super(...arguments),this.location={x:0,y:0}}dragStart(t){this._dragOffset=t.sub(this.location)}dragConstraint(t){if(t instanceof R)return this.constraint(t,this.location);{let e=new T(this.location),i=this.constraint(t.sub(this._dragOffset).sub(e),e);return e.add(i).add(this._dragOffset)}}drag(t){t instanceof T?(t=t.sub(this._dragOffset)).eq(this.location)||this.design.history.takeAction((()=>{this.location.x=t.x,this.location.y=t.y,this.onDragged()})):t.eq(R.ZERO)||this.design.history.takeAction((()=>{this.location.x+=t.x,this.location.y+=t.y,this.onDragged()}))}onDragged(){}constraint(t,e){return R.ZERO}static relocate(t,e){if(!t||!e)return;let i=t.sheet,s=e.sheet;e.location.x=Math.round(t.location.x/i.width*s.width),e.location.y=Math.round(t.location.y/i.height*s.height)}}t([e],Y.prototype,"location",void 0);class U extends Y{constructor(){super(...arguments),this._isNew=!0}get isNew(){return this._isNew}set isNew(t){t||(this._isNew=t)}watchIsNew(){this._isNew&&this.sheet!=this.design.sheet&&(this._isNew=!1)}}t([e],U.prototype,"watchIsNew",null);let Z=class extends z{constructor(t){super(t),this.$addItem(xt.shade,this._shade=new paper.Path.Rectangle(bt.shade)),this.$addItem(xt.hinge,this.hinge=new paper.Path.Rectangle(bt.hinge)),this.$addItem(xt.shade,this._circle=new paper.Path(bt.circle)),this._dots=Mt((t=>{let e=new paper.Path.Circle(bt.dot);return this.$addItem(xt.dot,e),e})),this.$addItem(xt.ridge,this._innerRidges=new paper.CompoundPath(bt.ridge)),this.$addItem(xt.ridge,this._outerRidges=new paper.CompoundPath(bt.ridge)),this.$addItem(xt.label,this._glow=new paper.PointText(bt.glow)),this.$addItem(xt.label,this._label=new paper.PointText(bt.label))}contains(t){return this.control.sheet.view.contains(t)&&(this.hinge.contains(t)||null!=this.hinge.hitTest(t))}get circle(){return this.makeRectangle(0)}makeRectangle(t){let e=this.control.points,i=this.control.node.radius+t;return new paper.Path.Rectangle({from:[e[2].x-i,e[2].y-i],to:[e[0].x+i,e[0].y+i],radius:i})}makeContour(t){let e=new paper.Path({closed:!0});this.control.quadrants.forEach((i=>e.add(...i.makeContour(t))));let i=e;for(let e of this.control.quadrants)for(let s of e.getOverriddenPath(t))i=i.subtract(s,{insert:!1});return i}renderHinge(){var t,e;this._circle.visible=null!==(e=null===(t=this.$studio)||void 0===t?void 0:t.$display.settings.showHinge)&&void 0!==e&&e,this.hinge.removeSegments(),this.control.quadrants.forEach((t=>this.hinge.add(...t.makeContour(0))))}render(){let t=this.control.sheet.displayScale,e=this.control.width,i=this.control.height;this._circle.copyContent(this.circle),this.renderHinge();let s=Mt((e=>{let i=this.control.points[e].toPaper();return this._dots[e].position.set((e=>[e.x*t,-e.y*t])(i)),i}));this._dots[2].visible=e>0||i>0,this._dots[1].visible=this._dots[3].visible=e>0&&i>0,this._innerRidges.removeChildren(),this._innerRidges.moveTo(s[3]),s.forEach((t=>this._innerRidges.lineTo(t))),this._innerRidges.visible=e>0||i>0,this._outerRidges.removeChildren(),this.control.quadrants.forEach(((t,e)=>{null==t.pattern&&Wt.addLine(this._outerRidges,s[e],t.corner)})),this._label.content=this.control.node.name,Vt.setLabel(this.control.sheet,this._label,this._glow,this.control.dragSelectAnchor,this._dots[0]),this._shade.copyContent(this.hinge)}renderSelection(t){this._shade.visible=t}};t([e],Z.prototype,"circle",null),t([e],Z.prototype,"renderHinge",null),Z=t([e],Z);let X=class extends z{constructor(t){super(t),this.$addItem(xt.ridge,this.line=new paper.Path.Line(bt.edge)),this.$addItem(xt.label,this._glow=new paper.PointText(bt.glow)),this.$addItem(xt.label,this._label=new paper.PointText(bt.label)),this._lineRegion=new paper.Path.Line({strokeWidth:15})}contains(t){return!(null==this._lineRegion.hitTest(t)&&null==this._glow.hitTest(t.transform(this._glow.layer.matrix.inverted()))||this.control.v1.view.contains(t)||this.control.v2.view.contains(t))}render(){let t=this.control.v1.location,e=this.control.v2.location,i={x:(t.x+e.x)/2,y:(t.y+e.y)/2};this._lineRegion.segments[0].point.set([t.x,t.y]),this._lineRegion.segments[1].point.set([e.x,e.y]),this.line.copyContent(this._lineRegion),this._label.content=this.control.length.toString(),Vt.setLabel(this.control.sheet,this._label,this._glow,i,this.line)}renderSelection(t){let e=t?Wt.Red():Wt.Black();this._label.fillColor=this._label.strokeColor=this.line.strokeColor=e,this.line.strokeWidth=t?3:2}};X=t([e],X);let tt=class extends z{constructor(t){super(t);let e=Object.assign({},bt.dot,{radius:4});this.$addItem(xt.dot,this._dot=new paper.Path.Circle(e)),this.$addItem(xt.label,this._glow=new paper.PointText(bt.glow)),this.$addItem(xt.label,this._label=new paper.PointText(bt.label)),this._circle=new paper.Path.Circle({radius:.4})}contains(t){return this._circle.contains(t)||null!=this._glow.hitTest(t.transform(this._glow.layer.matrix.inverted()))}render(){let t=this.control.sheet.displayScale,e=this.control.location.x,i=this.control.location.y;this._circle.position.set([e,i]),this._dot.position.set([e*t,-i*t]);let s=this.control.node.edges.map((t=>{let e=this.control.sheet.design.edges.get(t).view;return e.draw(),e.line}));this._label.content=this.control.node.name,Vt.setLabel(this.control.sheet,this._label,this._glow,{x:e,y:i},this._dot,...s)}renderSelection(t){this._dot.set(t?bt.dotSelected:bt.dot)}};var et;tt=t([e],tt);let it=et=class extends U{constructor(t,e){super(t),this.width=0,this.height=0,this.node=e;let i=t.design,s=i.options.get("flap",e.id);s?(this.location.x=s.x,this.location.y=s.y,this.width=s.width,this.height=s.height,this.isNew=!1):Y.relocate(i.vertices.get(this.node),this),this.quadrants=Mt((e=>new j(t,this,e))),this.view=new Z(this)}get type(){return"Flap"}selectableWith(t){return t instanceof et}get dragSelectAnchor(){return{x:this.location.x+this.width/2,y:this.location.y+this.height/2}}get points(){let t=this.location.x,e=this.location.y,i=this.width,s=this.height;return[new T(t+i,e+s),new T(t,e+s),new T(t,e),new T(t+i,e)]}get name(){return this.node.name}set name(t){this.node.name=t}get radius(){var t,e;return null!==(e=null===(t=this.node.firstEdge)||void 0===t?void 0:t.length)&&void 0!==e?e:0}set radius(t){this.node.firstEdge.length=t}onDragged(){this.isNew&&Y.relocate(this,this.design.vertices.get(this.node))}get shouldDispose(){return super.shouldDispose||this.node.disposed||1!=this.node.degree}toJSON(){return{id:this.node.jid,width:this.width,height:this.height,x:this.location.x,y:this.location.y}}constraint(t,e){return this.sheet.constraint(t,e),this.sheet.constraint(t,{x:e.x+this.width,y:e.y+this.height}),t}debug(t=0){console.log(this.view.makeContour(t).exportJSON())}};var st;t([s({validator(t){let e=t>=0&&t<=this.sheet.width,i=this.location.x+t-this.sheet.width;return i>0&&(this.location.x-=i),e}})],it.prototype,"width",void 0),t([s({validator(t){let e=t>=0&&t<=this.sheet.height,i=this.location.y+t-this.sheet.height;return i>0&&(this.location.y-=i),e}})],it.prototype,"height",void 0),t([e],it.prototype,"dragSelectAnchor",null),t([e],it.prototype,"points",null),it=et=t([e],it);let nt=st=class extends U{constructor(t,e){super(t),this.height=0,this.width=0,this.node=e;let i=t.design.options.get("vertex",this.node.id);i&&(null!=i.name&&(this.node.name=i.name),this.location.x=i.x,this.location.y=i.y,this.isNew=!!i.isNew),this.view=new tt(this)}get type(){return"Vertex"}get name(){return this.node.name}set name(t){this.node.name=t}get degree(){return this.node.degree}selectableWith(t){return t instanceof st}get dragSelectAnchor(){return this.location}onDragged(){this.isNew&&Y.relocate(this,this.design.flaps.get(this.node))}addLeaf(t=1){this.design.history.takeAction((()=>{let e=[...this.design.vertices.values()],i=this.node.addLeaf(t),s=this.findClosestEmptyPoint(e);this.design.options.set("vertex",i.id,{id:i.id,name:i.name,x:s.x,y:s.y,isNew:!0})}))}findClosestEmptyPoint(t){let{x:e,y:i}=this.location,s=new T(e+.125,i+.0625),n=[],r=new Set;for(let e of t)r.add(e.location.x+","+e.location.y);for(let t=e-5;t<=e+5;t++)for(let e=i-5;e<=i+5;e++)if(!r.has(t+","+e)){let i=new T(t,e);n.push([i,i.dist(s)])}return n.sort(((t,e)=>t[1]-e[1])),n[0][0]}deleteAndJoin(){2==this.node.degree&&this.design.history.takeAction((()=>{let t=this.node.dispose();Shrewd.commit(),this.design.edges.get(t).selected=!0}))}get shouldDispose(){return super.shouldDispose||this.node.disposed}toJSON(){return{id:this.node.jid,name:this.name,x:this.location.x,y:this.location.y}}constraint(t,e){return this.sheet.constraint(t,e),t}};nt=st=t([e],nt);let rt=class{constructor(t){if(this.designMap=new Map,this.design=null,"object"!=typeof paper)throw new Error("BPStudio requires paper.js.");let e=document.querySelector(t);if(null==e||!(e instanceof HTMLElement))throw new Error("selector is not valid");this.$el=e,this.$paper=new paper.PaperScope,this.$display=new at(this),this.system=new ft(this)}load(t){return"string"==typeof t&&(t=JSON.parse(t)),this.tryLoad(ct.process(t,this.onDeprecate))}create(t){return Object.assign(t,{version:ct.current,tree:{nodes:[{id:0,name:"",x:10,y:7},{id:1,name:"",x:10,y:10},{id:2,name:"",x:10,y:13}],edges:[{n1:0,n2:1,length:1},{n1:2,n2:1,length:1}]}}),this.restore(t)}restore(t){let e=new E(this,ct.process(t,this.onDeprecate));return this.designMap.set(e.id,e),e}select(t){if(null!=t){let e=this.designMap.get(t);e&&(this.design=e)}else this.design=null}close(t){let e=this.designMap.get(t);e&&(this.designMap.delete(t),e.dispose())}closeAll(){this.design=null;for(let t of this.designMap.values())t.dispose();this.designMap.clear()}tryLoad(t){return this.design=new E(this,t),this.designMap.set(this.design.id,this.design),Shrewd.commit(),this.design}toBPS(){if(!this.design)return"";let t=this.design.toJSON();delete t.history;let e=JSON.stringify(t),i=new Blob([e],{type:"application/octet-stream"});return URL.createObjectURL(i)}get TreeMaker(){return Lt}};t([e],rt.prototype,"design",void 0),rt=t([e],rt);let ot=class extends F{constructor(t,e,i,s){super(t),this.v1=e,this.v2=i,this.edge=s,this.view=new X(this)}get type(){return"Edge"}get shouldDispose(){return super.shouldDispose||this.edge.disposed}split(){this.design.history.takeAction((()=>this.toVertex(b.prototype.split)))}deleteAndMerge(){this.design.history.takeAction((()=>this.toVertex(b.prototype.deleteAndMerge)))}toVertex(t){let e=this.v1.location,i=this.v2.location,s=Math.round((e.x+i.x)/2),n=Math.round((e.y+i.y)/2),r=t.apply(this.design.tree,[this.edge]);this.design.options.set("vertex",r.id,{id:r.id,name:r.name,x:s,y:n}),Shrewd.commit(),this.design.vertices.get(r).selected=!0}get length(){return this.edge.length}set length(t){this.edge.length=t}toJSON(){return{n1:this.v1.node.jid,n2:this.v2.node.jid,length:this.edge.length}}};ot=t([e],ot);let ht=class extends q{constructor(t,e,i){super(t),e.node.id>i.node.id&&([e,i]=[i,e]),this.f1=e,this.f2=i,this.id=e.node.id+":"+i.node.id,new G(this)}static createTeamId(t,e){let i=new Set;return t.forEach((t=>{i.add(e(t.f1)),i.add(e(t.f2))})),Array.from(i).sort(((t,e)=>t-e)).join(",")}static sort(t,e){let i=t.f1.node.id-e.f1.node.id;return 0!=i?i:t.f2.node.id-e.f2.node.id}get shouldDispose(){return super.shouldDispose||this.f1.disposed||this.f2.disposed}get baseRectangle(){if(!this.isValid)return;let t=this.sx>0?this.q2:this.q1;return null==t?void 0:t.getBaseRectangle(this)}isCoveredBy(t){if(this==t||this.direction%2!=t.direction%2)return!1;let[e,i]=[t.baseRectangle,this.baseRectangle];return!!(e&&i&&e.contains(i))&&(!e.equals(i)||(Math.abs(t.sx)<Math.abs(this.sx)||Math.abs(t.sy)<Math.abs(this.sy)))}get coveredBy(){return this.isValid?this.sheet.design.validJunctions.filter((t=>this.isCoveredBy(t))):[]}get isCovered(){return this.coveredBy.some((t=>0==t.coveredBy.length))}toJSON(){return{c:[{type:mt.flap,e:this.f1.node.id,q:this.q1.q},{type:mt.side},{type:mt.flap,e:this.f2.node.id,q:this.q2.q},{type:mt.side}],ox:this.ox,oy:this.oy,sx:this.sx<0?-this.sx:this.sx}}get neighbors(){if(this.direction>3)return[];let t=this.q1.activeJunctions.concat(),e=this.q2.activeJunctions.concat();return t.splice(t.indexOf(this),1),e.splice(e.indexOf(this),1),t.concat(e)}get q1(){return qt(this.direction)?this.f1.quadrants[this.direction]:null}get q2(){return qt(this.direction)?this.f2.quadrants[It(this.direction)]:null}get $treeDistance(){return this.design.tree.dist(this.f1.node,this.f2.node)}get status(){return this._flapDistance<this.$treeDistance?vt.tooClose:this.ox&&this.oy?vt.overlap:vt.tooFar}get fx(){return-Math.sign(this.sx)}get fy(){return-Math.sign(this.sy)}get ox(){let t=this.$treeDistance-Math.abs(this.sx);return t>0?t:NaN}get oy(){let t=this.$treeDistance-Math.abs(this.sy);return t>0?t:NaN}get sx(){let t=this.f1.location.x,e=this.f2.location.x,i=this.f1.width,s=t-e-this.f2.width;return s>=0?s:(s=t+i-e,s<=0?s:NaN)}get sy(){let t=this.f1.location.y,e=this.f2.location.y,i=this.f1.height,s=t-e-this.f2.height;return s>=0?s:(s=t+i-e,s<=0?s:NaN)}get direction(){let t=this.sx,e=this.sy;return t<0&&e<0?_t.UR:t>0&&e<0?_t.UL:t>0&&e>0?_t.LL:t<0&&e>0?_t.LR:t<0?_t.R:t>0?_t.L:e<0?_t.T:e>0?_t.B:_t.none}get _flapDistance(){let t=this.sx,e=this.sy,i=0!=t&&!isNaN(t),s=0!=e&&!isNaN(e);return i&&s?Math.sqrt(t*t+e*e):i?Math.abs(t):s?Math.abs(e):0}get isValid(){return this.status==vt.overlap}static findMinMax(t,e,i){let s=t[0][e],n=t[0];for(let r=1;r<t.length;r++)t[r][e]*i>s*i&&(n=t[r],s=t[r][e]);return n}};t([e],ht.prototype,"baseRectangle",null),t([e],ht.prototype,"coveredBy",null),t([e],ht.prototype,"isCovered",null),t([e],ht.prototype,"neighbors",null),t([e],ht.prototype,"q1",null),t([e],ht.prototype,"q2",null),t([e],ht.prototype,"$treeDistance",null),t([e],ht.prototype,"status",null),t([e],ht.prototype,"fx",null),t([e],ht.prototype,"fy",null),t([e],ht.prototype,"ox",null),t([e],ht.prototype,"oy",null),t([e],ht.prototype,"sx",null),t([e],ht.prototype,"sy",null),t([e],ht.prototype,"direction",null),t([e],ht.prototype,"_flapDistance",null),t([e],ht.prototype,"isValid",null),ht=t([e],ht);let lt=class extends F{constructor(t,e){super(t),this.edge=e,this.view=new Q(this)}get type(){return"River"}get shouldDispose(){return super.shouldDispose||this.edge.disposed||!this.edge.isRiver}delete(){this.design.edges.get(this.edge).deleteAndMerge()}get length(){return this.edge.length}set length(t){this.edge.length=t}};lt=t([e],lt);let at=class{constructor(t){this.MARGIN=30,this.lockViewport=!1,this.settings={showAxialParallel:!0,showGrid:!0,showHinge:!0,showRidge:!0,showLabel:!0,showDot:!0,includeHiddenElement:!1},this._printing=!1,this._studio=t,t.$el.appendChild(this.spaceHolder=document.createElement("div")),t.$el.addEventListener("scroll",this.onScroll.bind(this)),this.spaceHolder.style.zIndex="-10",this._canvas=document.createElement("canvas"),t.$el.appendChild(this._canvas),window.addEventListener("resize",this.setSize.bind(this)),this.setSize(),setTimeout((()=>this.setSize()),10),window.addEventListener("beforeprint",this.beforePrint.bind(this)),window.addEventListener("afterprint",this.afterPrint.bind(this));let e=matchMedia("(hover: none), (pointer: coarse)").matches;document.addEventListener("focusin",(t=>{e&&(t.target instanceof HTMLInputElement||t.target instanceof HTMLTextAreaElement)&&(this.lockViewport=!0)})),document.addEventListener("focusout",(t=>this.lockViewport=!1)),t.$paper.setup(this._canvas),t.$paper.settings.insertItems=!1,this.project=t.$paper.project,this.project.currentStyle.strokeColor=Wt.Black(),this.project.currentStyle.strokeScaling=!1;for(let t of yt.values(xt))this.project.addLayer(new paper.Layer({name:xt[t]}));this.boundary=new paper.Path.Rectangle({from:[0,0],to:[0,0]});for(let t of yt.values(xt))wt[t].clipped&&(this.project.layers[t].addChild(this.boundary.clone()),this.project.layers[t].clipped=!0)}setSize(){this.lockViewport||(this.viewWidth=this._studio.$el.clientWidth,this.viewHeight=this._studio.$el.clientHeight)}toSVG(){let t=Math.max(this.sheetWidth,this.viewWidth),e=Math.max(this.sheetHeight,this.viewHeight),i=(t-this.sheetWidth)/2-this.scroll.x,s=(e-this.sheetHeight)/2-this.scroll.y,n=new paper.Rectangle(i,s,this.sheetWidth,this.sheetHeight),r=this._studio.$paper.project.exportSVG({bounds:n,matrix:this.project.view.matrix});this.settings.includeHiddenElement||this.removeHidden(r);let o=new Blob([r.outerHTML],{type:"image/svg+xml"});return URL.createObjectURL(o)}removeHidden(t){let e=Array.from(t.children);for(let i of e)"hidden"==i.getAttribute("visibility")?t.removeChild(i):this.removeHidden(i)}get img(){return this._img||this.spaceHolder.appendChild(this._img=new Image),this._img}createPNG(){let t=document.createElement("canvas"),e=t.getContext("2d"),i=this.img;return new Promise((s=>{i.addEventListener("load",(()=>{t.width=i.clientWidth,t.height=i.clientHeight,e.fillStyle="white",e.fillRect(0,0,t.width,t.height),e.drawImage(i,0,0,i.naturalWidth,i.naturalHeight,0,0,i.clientWidth,i.clientHeight),this._printing=!1,t.toBlob((t=>s(t)))}),{once:!0}),this.beforePrint()}))}toPNG(){return this.createPNG().then((t=>URL.createObjectURL(t)))}copyPNG(){return this.createPNG().then((t=>navigator.clipboard.write([new ClipboardItem({"image/png":t})])))}beforePrint(){if(clearTimeout(this._debounce),!this._printing&&"visible"==document.visibilityState){let t=this.img.src;setTimeout((()=>URL.revokeObjectURL(t)),5e3),this.img.src=this.toSVG(),this._printing=!0}}afterPrint(){this._debounce=setTimeout((()=>{this._printing=!1,this._debounce=NaN}),1e3)}onScroll(){var t;let e=null===(t=this._studio.design)||void 0===t?void 0:t.sheet;e&&(e.scroll.x=this._studio.$el.scrollLeft,e.scroll.y=this._studio.$el.scrollTop)}get scroll(){var t,e;return null!==(e=null===(t=this._studio.design)||void 0===t?void 0:t.sheet.scroll)&&void 0!==e?e:{x:0,y:0}}get scale(){if(this._studio.design&&this._studio.design.sheet){if(this._studio.design.fullscreen){let t=(this.viewWidth-2*this.horMargin)/this._studio.design.sheet.width,e=(this.viewHeight-2*this.MARGIN)/this._studio.design.sheet.height;return Math.min(t,e)}return this._studio.design.sheet.scale}return 1}get horMargin(){var t,e;return Math.max((null!==(e=null===(t=this._studio.design)||void 0===t?void 0:t.sheet.margin)&&void 0!==e?e:0)+10,this.MARGIN)}get sheetWidth(){var t,e,i;return(null!==(i=null===(e=null===(t=this._studio.design)||void 0===t?void 0:t.sheet)||void 0===e?void 0:e.width)&&void 0!==i?i:0)*this.scale+2*this.horMargin}get sheetHeight(){var t,e,i;return(null!==(i=null===(e=null===(t=this._studio.design)||void 0===t?void 0:t.sheet)||void 0===e?void 0:e.height)&&void 0!==i?i:0)*this.scale+2*this.MARGIN}get isXScrollable(){return this.sheetWidth>this.viewWidth+1}get isYScrollable(){return this.sheetHeight>this.viewHeight+1}getAutoScale(){var t,e,i;let s=null===(t=this._studio.design)||void 0===t?void 0:t.sheet,n=(this.viewWidth-2*this.horMargin)/(null!==(e=null==s?void 0:s.width)&&void 0!==e?e:1),r=(this.viewHeight-2*this.MARGIN)/(null!==(i=null==s?void 0:s.height)&&void 0!==i?i:1);return Math.min(n,r)}isScrollable(){return this._studio.$el.classList.toggle("scroll-x",this.isXScrollable),this._studio.$el.classList.toggle("scroll-y",this.isYScrollable),this.isXScrollable||this.isYScrollable}renderSetting(){var t,e;let i=null!==(e="layout"!=(null===(t=this._studio.design)||void 0===t?void 0:t.mode))&&void 0!==e&&e;this.project.layers[xt.hinge].visible=this.settings.showHinge,this.project.layers[xt.ridge].visible=this.settings.showRidge||i,this.project.layers[xt.axisParallel].visible=this.settings.showAxialParallel,this.project.layers[xt.label].visible=this.settings.showLabel,this.project.layers[xt.dot].visible=this.settings.showDot||i}onSheetChange(){var t;let e=null===(t=this._studio.design)||void 0===t?void 0:t.sheet;e&&(this._studio.$el.scrollLeft=e.scroll.x,this._studio.$el.scrollTop=e.scroll.y)}render(){let t=0,e=0,i=this.scale;this._studio.design&&this._studio.design.sheet&&({width:t,height:e}=this._studio.design.sheet);let s=Math.max(this.sheetWidth,this.viewWidth),n=Math.max(this.sheetHeight,this.viewHeight);this.spaceHolder.style.width=s+"px",this.spaceHolder.style.height=n+"px",Wt.setRectangleSize(this.boundary,t,e);let r=this._studio.$el,o=(s-this.sheetWidth)/2+this.horMargin,h=(n+this.sheetHeight)/2-this.MARGIN;this.lockViewport?this.project.view.viewSize.set(this.viewWidth,this.viewHeight):this.project.view.viewSize.set(r.clientWidth,r.clientHeight),this.project.view.matrix.set(i,0,0,-i,o-this.scroll.x,h-this.scroll.y);for(let t of yt.values(xt)){let e=this.project.layers[t];wt[t].clipped&&e.children[0].set({segments:this.boundary.segments}),wt[t].scaled||(e.applyMatrix=!1,e.matrix.set(1/i,0,0,-1/i,0,0))}}};t([e],at.prototype,"viewWidth",void 0),t([e],at.prototype,"viewHeight",void 0),t([e],at.prototype,"settings",void 0),t([e],at.prototype,"scale",null),t([e],at.prototype,"horMargin",null),t([e],at.prototype,"sheetWidth",null),t([e],at.prototype,"sheetHeight",null),t([e],at.prototype,"isXScrollable",null),t([e],at.prototype,"isYScrollable",null),t([e],at.prototype,"isScrollable",null),t([e],at.prototype,"renderSetting",null),t([e],at.prototype,"onSheetChange",null),t([e],at.prototype,"render",null),at=t([e],at);class dt{constructor(t){this._modified=!1,this.design=t}get modified(){return this._modified}notifySave(){this._modified=!1}takeAction(t){this._modified=!0,t()}fieldChange(t,e,i,s){this._modified=!0}}var ct,ut;!function(t){function e(t,e){let i=[],s=new Map;for(let[e,n]of t.entries()){if(s.has(e))continue;let r=n.c.filter((t=>t.type==mt.coincide)),o=r.find((t=>s.has(-t.e-1))),h=i.length;if(o){let t=s.get(-o.e-1);s.set(e,t),i[t].push(n)}else s.set(e,h),i.push([n]);r.forEach((n=>{e=-n.e-1,s.has(e)||(s.set(e,h),i[h].push(t[e]))}))}return i.map((t=>({overlaps:t,strategy:e})))}t.current="0",t.getSample=function(){return{title:"",version:t.current,fullscreen:!0,mode:"layout",history:{index:0,modified:!1,actions:[]},layout:{sheet:{width:16,height:16,scale:20},flaps:[],stretches:[]},tree:{sheet:{width:20,height:20,scale:16},nodes:[],edges:[]}}},t.process=function(t,i){var s;let n=!1;if("version"in t||("cp"==t.mode&&(t.mode="layout"),t.layout=t.cp,delete t.cp,t.version="beta",delete t.layout.stretches,n=!0),"beta"==t.version){t.version="rc0";let e=t.layout.stretches;if(e)for(let t of e.concat()){let i=t.configuration;!i||i.overlaps&&!i.overlaps.some((t=>t.c.some((t=>t.type==mt.intersection&&void 0===t.e))))||(e.splice(e.indexOf(t),1),n=!0)}}if("rc0"==t.version){t.version="rc1";let i=t.layout.stretches;if(i)for(let t of i.concat()){if(t.configuration){t.configuration={partitions:e(t.configuration.overlaps,t.configuration.strategy)},t.pattern&&(1==t.configuration.partitions.length?t.pattern={devices:[{gadgets:t.pattern.gadgets,offset:null===(s=t.pattern.offsets)||void 0===s?void 0:s[0]}]}:t.pattern={devices:t.pattern.gadgets.map(((e,i)=>{var s;return{gadgets:[e],offset:null===(s=t.pattern.offsets)||void 0===s?void 0:s[i]}}))})}}}return"rc1"==t.version&&(t.version="0"),n&&i&&i(t.title),t}}(ct||(ct={}));class pt{constructor(t){this.options=new Map;for(let e of t.tree.nodes)this.set("vertex",e.id,e);for(let e of t.layout.flaps)this.set("flap",e.id,e);for(let e of t.layout.stretches)this.set("stretch",e.id,e)}get(t,e){e=t+e;let i=this.options.get(e);return this.options.delete(e),i}set(t,e,i){this.options.set(t+e,i)}}const gt="undefined"!=typeof TouchEvent;let ft=ut=class{constructor(t){this.dragging=!1,this._spaceDown=!1,this._touchScaling=[0,0],this._scrolled=!1,this._possiblyReselect=!1,this._studio=t;let e=t.$paper.view.element,i=t.$paper.tool=new paper.Tool;i.onKeyDown=this._canvasKeydown.bind(this),i.onKeyUp=this._canvasKeyup.bind(this),i.onMouseDown=this._canvasMousedown.bind(this),i.onMouseDrag=this._canvasMouseDrag.bind(this),i.onMouseUp=this._canvasMouseup.bind(this),e.addEventListener("wheel",this._canvasWheel.bind(this)),e.addEventListener("touchstart",this._canvasTouch.bind(this)),document.addEventListener("mousemove",this._bodyMousemove.bind(this)),document.addEventListener("touchmove",this._bodyMousemove.bind(this)),document.addEventListener("mouseup",this._bodyMouseup.bind(this)),document.addEventListener("touchend",this._bodyMouseup.bind(this)),document.addEventListener("contextmenu",this._bodyMenu.bind(this)),this._dragSelectView=new B(t)}static controlPriority(t){return t instanceof Ot||t instanceof nt?1:t instanceof it||t instanceof ot?2:3}get _controls(){let t=this._studio.design?this._studio.design.sheet.activeControls.concat():[];return t.sort(((t,e)=>ut.controlPriority(t)-ut.controlPriority(e))),this._dragSelectables=t.filter(D.isDragSelectable),t.length||(this._ctrl=[null,null]),t}get selections(){return this._controls.filter((t=>t.selected))}draggableSelections(){return this.selections.filter((t=>t instanceof Y))}get _canvas(){return this._studio.$paper.view.element}_processSelection(t,e){var i=null,s=null,n=null,r=this._controls.filter((e=>e.contains(t)));for(let t of r)i||(i=t),t.selected?s=t:s&&!n&&(n=t);if(n||!i||i.selected||(n=i),s){let t=ut.controlPriority(s);r.some((e=>ut.controlPriority(e)<t))&&(this._possiblyReselect=!0)}e?(s&&!n&&s.toggle(),n&&this._select(n)):(s||this._clearSelection(),!s&&n&&this._select(n)),this._ctrl=[s,n]}_processNextSelection(){var[t,e]=this._ctrl;this._studio.design&&!this._studio.design.dragging&&(t&&e&&this._clearSelection(),t&&!e&&this._clearSelection(t),e&&this._select(e))}_select(t){t.selected||0!=this.selections.length&&!this.selections[0].selectableWith(t)||(t.selected=!0)}_clearSelection(t=null){this._dragSelectView.visible=!1;for(let e of this.selections)e!=t&&(e.selected=!1)}_checkEvent(t){return!(this.isTouch(t)&&t.touches.length>1)&&!(t instanceof MouseEvent&&0!=t.button)}_canvasKeydown(t){let e=document.activeElement;return e instanceof HTMLInputElement||e instanceof HTMLTextAreaElement||this.key(t.key,t.modifiers.control)}key(t,e=!1){let i=new R(0,0);switch(t){case"space":return this._studio.$display.isScrollable()&&(this._canvas.style.cursor="grab",this._spaceDown=!0),!1;case"delete":let t=this.selections[0];return t instanceof it&&this._studio.design.deleteFlaps(this.selections),t instanceof nt&&this._studio.design.deleteVertices(this.selections),!1;case"a":let s=this._studio.design;return e&&s&&(this._clearSelection(),"layout"==s.mode&&s.flaps.forEach((t=>t.selected=!0)),"tree"==s.mode&&s.vertices.forEach((t=>t.selected=!0))),!1;case"up":i.set(0,1);break;case"down":i.set(0,-1);break;case"left":i.set(-1,0);break;case"right":i.set(1,0);break;default:return!0}let s=this.draggableSelections();if(0==s.length)return!0;s[0]instanceof Ot&&(i=i.scale(2));for(let t of s)i=t.dragConstraint(i);for(let t of s)t.drag(i);return!1}_canvasKeyup(){this._canvas.style.cursor="unset",this._spaceDown=!1}_canvasMousedown(t){if(t.event instanceof MouseEvent&&(this._spaceDown||2==t.event.button))return console.log(t.point.round().toString()),void this._setScroll(t.event);let e=document.activeElement;if(e instanceof HTMLElement&&e.blur(),!this._checkEvent(t.event)||this._scrollStart)return;let i=t.point;if(this._processSelection(i,t.modifiers.control),1==this.selections.length&&this.isTouch(t.event)&&(this._longPressTimeout=window.setTimeout((()=>{this.onLongPress()}),750)),this.draggableSelections().length){this._lastKnownCursorLocation=new T(t.downPoint).round();for(let t of this.draggableSelections())t.dragStart(this._lastKnownCursorLocation);this.dragging=!0}}_canvasMouseup(t){this._dragSelectView.visible=!1,this._checkEvent(t.event)&&(this._scrollStart?t.event instanceof MouseEvent&&(this._scrollStart=null):t.modifiers.control||this._processNextSelection())}_reselect(t){this._clearSelection(),this._processSelection(t.point,!1),Shrewd.commit();for(let t of this.draggableSelections())t.dragStart(this._lastKnownCursorLocation);this._possiblyReselect=!1}_canvasMouseDrag(t){var e;if(!this._scrollStart)if(this._possiblyReselect&&(this._reselect(t),this.dragging=!0),this.dragging){let i=new T(t.point).round();if(this._lastKnownCursorLocation.eq(i))return;window.clearTimeout(this._longPressTimeout),null===(e=this.onDrag)||void 0===e||e.apply(null),this._lastKnownCursorLocation.set(i);for(let t of this.draggableSelections())i=t.dragConstraint(i);for(let t of this.draggableSelections())t.drag(i);this._studio.design.dragging=!0}else if(this._dragSelectables.length){if(!this._dragSelectView.visible){if(this.isTouch(t.event)&&t.downPoint.getDistance(t.point)<1)return;this._clearSelection(),this._dragSelectView.visible=!0,this._dragSelectView.down=t.downPoint,Shrewd.commit()}this._dragSelectView.now=t.point,this._dragSelectView.draw();for(let t of this._dragSelectables)t.selected=this._dragSelectView.contains(new paper.Point(t.dragSelectAnchor))}}_canvasWheel(t){if(t.ctrlKey){t.preventDefault();let e=this._studio.design;e&&(e.fullscreen&&(e.sheet.scale=Math.round(this._studio.$display.scale),e.fullscreen=!1),e.sheet.scale-=Math.round(t.deltaY/100))}}_canvasTouch(t){t.touches.length>1&&(this._clearSelection(),this._setScroll(t),this._touchScaling=[this.getTouchDistance(t),this._studio.$display.scale])}getTouchDistance(t){let e=t.touches,i=e[1].screenX-e[0].screenX,s=e[1].screenY-e[0].screenY;return Math.sqrt(i*i+s*s)}_bodyMousemove(t){var e;if(this._scrollStart&&(t instanceof MouseEvent||t.touches.length>=2)){let i=this.isTouch(t)?t.touches[0]:t,s=new T(i.screenX,i.screenY).sub(this._lastKnownCursorLocation),n=this._studio.$el;if(this._studio.$display.isXScrollable&&(n.scrollLeft=this._scrollStart.x-s.x),this._studio.$display.isYScrollable&&(n.scrollTop=this._scrollStart.y-s.y),this.isTouch(t)){let i=null===(e=this._studio.design)||void 0===e?void 0:e.sheet;if(i){let e=(this.getTouchDistance(t)-this._touchScaling[0])/30,s=this._studio.$display.getAutoScale();e=Math.round(e+this._touchScaling[1]),e<=s?(i.scale=Math.ceil(s),i.design.fullscreen=!0):(i.scale=Math.ceil(e),i.design.fullscreen=!1)}}this._scrolled=!0}}_setScroll(t){let e=this._studio.$el,i=this.isTouch(t)?t.touches[0]:t;window.clearTimeout(this._longPressTimeout),this._scrollStart=new T(e.scrollLeft,e.scrollTop),this._scrolled=!1,this._lastKnownCursorLocation=new T(i.screenX,i.screenY)}_bodyMouseup(t){this._dragEnd(),window.clearTimeout(this._longPressTimeout),this.isTouch(t)&&0==t.touches.length&&(this._scrollStart=null)}_dragEnd(){this.dragging=!1,this._studio.design&&(this._studio.design.dragging=!1)}_bodyMenu(t){t.preventDefault(),this._scrollStart=null}isTouch(t){return gt&&t instanceof TouchEvent}};var yt,vt,_t,xt,mt;t([e],ft.prototype,"_controls",null),t([e],ft.prototype,"selections",null),t([e],ft.prototype,"draggableSelections",null),t([e],ft.prototype,"dragging",void 0),ft=ut=t([e],ft),function(t){t.values=function(t){return Object.values(t).filter((t=>!isNaN(Number(t))))}}(yt||(yt={})),function(t){t[t.tooClose=0]="tooClose",t[t.overlap=1]="overlap",t[t.tooFar=2]="tooFar"}(vt||(vt={})),function(t){t[t.UR=0]="UR",t[t.UL=1]="UL",t[t.LL=2]="LL",t[t.LR=3]="LR",t[t.R=4]="R",t[t.T=5]="T",t[t.L=6]="L",t[t.B=7]="B",t[t.none=8]="none"}(_t||(_t={})),function(t){t[t.sheet=0]="sheet",t[t.shade=1]="shade",t[t.hinge=2]="hinge",t[t.ridge=3]="ridge",t[t.axisParallel=4]="axisParallel",t[t.junction=5]="junction",t[t.dot=6]="dot",t[t.label=7]="label",t[t.drag=8]="drag"}(xt||(xt={})),function(t){t[t.socket=0]="socket",t[t.internal=1]="internal",t[t.side=2]="side",t[t.intersection=3]="intersection",t[t.flap=4]="flap",t[t.coincide=5]="coincide"}(mt||(mt={}));const wt={[xt.sheet]:{clipped:!1,scaled:!0},[xt.shade]:{clipped:!0,scaled:!0},[xt.hinge]:{clipped:!0,scaled:!0},[xt.ridge]:{clipped:!0,scaled:!0},[xt.axisParallel]:{clipped:!0,scaled:!0},[xt.junction]:{clipped:!0,scaled:!0},[xt.dot]:{clipped:!1,scaled:!1},[xt.label]:{clipped:!1,scaled:!1},[xt.drag]:{clipped:!1,scaled:!0}};var bt;!function(t){t.circle={strokeWidth:1,strokeColor:"#69F"},t.dot={fillColor:"#69F",strokeWidth:1,strokeColor:"#000",radius:3},t.dotSelected={strokeWidth:3,strokeColor:"red"},t.hinge={strokeColor:"#69F",strokeWidth:3},t.sheet={strokeWidth:.25,strokeColor:"#000"},t.label={point:[0,0],fillColor:"black",fontWeight:"normal",strokeWidth:.5,fontSize:14},t.glow={point:[0,0],fontWeight:"normal",strokeWidth:2.5,strokeColor:"white",fontSize:14},t.edge={},t.ridge={strokeWidth:1.25,strokeColor:"red"},t.selection={strokeColor:"#69f",fillColor:"rgba(102, 153, 255, 0.2)"},t.shade={fillColor:"#69F",opacity:.3,strokeWidth:0},t.junction={strokeColor:"red",fillColor:"red",opacity:.3},t.axisParallel={strokeWidth:1,strokeColor:"green"},t.top={}}(bt||(bt={}));const St=[0,1,2,3];function Mt(t){return St.map(t)}function qt(t){return t<4}function It(t){return(t+2)%4}class Nt{constructor(t,e){e instanceof R&&(e=t.add(e)),this.p1=t,this.p2=e}toString(){return[this.p1,this.p2].sort().toString()}get isDegenerated(){return this.p1.eq(this.p2)}eq(t){return this.p1.eq(t.p1)&&this.p2.eq(t.p2)||this.p1.eq(t.p2)&&this.p2.eq(t.p1)}contains(t,e=!1){let i=t instanceof T?t:new T(t);if(e&&(i.eq(this.p1)||i.eq(this.p2)))return!0;var s=i.sub(this.p1),n=i.sub(this.p2);return s._x.mul(n._y).eq(n._x.mul(s._y))&&s.dot(n)<0}lineContains(t){return this.vector.parallel(t.sub(this.p1))}intersection(...t){if(void 0===t[1])return this.intersection(t[0].p1,t[0].p2.sub(t[0].p1));let[e,i,s]=t;var n=this.p2.sub(this.p1),r=new Ct(n._x,i._x,n._y,i._y).inverse;if(null==r)return null;var o=r.multiply(new T(e.sub(this.p1))),h=o._x,l=o._y.neg;return h.lt(0)||h.gt(1)||s&&l.lt(0)?null:e.add(i.scale(l))}transform(t,e){return new Nt(this.p1.transform(t,e),this.p2.transform(t,e))}shift(t){return new Nt(this.p1.add(t),this.p2.add(t))}static distinct(t){let e=new Set;return t.filter((t=>{let i=t.toString(),s=!e.has(i);return s&&e.add(i),s}))}static subtract(t,e){let i=[],s=new Map;for(let t of e){let e=t.slope.toString(),i=s.get(e);i||s.set(e,i=[]),i.push(t)}for(let e of t){let t=e.slope.toString();s.has(t)?i.push(...e.cancel(s.get(t))):i.push(e)}return i}cancel(t){let e=[this];for(let i of t){let t=[];for(let s of e)t.push(...s._cancel(i));e=t}return e}*_cancel(t){let e=this.contains(t.p1,!0),i=this.contains(t.p2,!0),s=t.contains(this.p1,!0),n=t.contains(this.p2,!0);if(!s||!n)if(!e&&!i||!s&&!n)yield this;else if(e&&i){let e=new Nt(this.p1,t.p1),i=new Nt(this.p1,t.p2),s=new Nt(this.p2,t.p1),n=new Nt(this.p2,t.p2);e.isDegenerated?yield n:i.isDegenerated?yield s:s.isDegenerated?yield i:n.isDegenerated?yield e:e.contains(t.p2)?(yield i,yield s):(yield e,yield n)}else{let i=e?t.p1:t.p2,s=n?this.p1:this.p2;i.eq(s)||(yield new Nt(i,s))}}get slope(){return this.p1._x.sub(this.p2._x).d(this.p1._y.sub(this.p2._y))}xOrient(){return this.p1._x.gt(this.p2._x)?[this.p2,this.p1]:[this.p1,this.p2]}*gridPoints(){let{p1:t,p2:e}=this,i=e.x-t.x,s=e.y-t.y;if(Math.abs(i)<Math.abs(s)){let s=Math.sign(i);for(let i=Ft.int(t.x,s);i*s<=e.x*s;i+=s){let t=this.xIntersection(i);t.isIntegral&&(yield t)}}else{let i=Math.sign(s);for(let s=Ft.int(t.y,i);s*i<=e.y*i;s+=i){let t=this.yIntersection(s);t.isIntegral&&(yield t)}}}xIntersection(t){let e=this.p2.sub(this.p1);return new T(t,this.p1._y.sub(e.slope.mul(this.p1._x.sub(t))).smp())}yIntersection(t){let e=this.p2.sub(this.p1);return new T(this.p1._x.sub(this.p1._y.sub(t).div(e.slope)).smp(),t)}reflect(t){t=t.neg;var e=new Ct(t._x,t._y.neg,t._y,t._x);return t=(t=e.inverse.multiply(this.p2.sub(this.p1))).doubleAngle(),e.multiply(t).reduce()}perpendicular(t){return 0==this.vector.dot(t)}get vector(){return this.p1.sub(this.p2)}}class Ct{constructor(t,e,i,s,n){this.a=new v(t),this.b=new v(e),this.c=new v(i),this.d=new v(s),this.det=n||this.a.mul(this.d).s(this.b.mul(this.c)).smp()}toString(){return[this.a,this.b,this.c,this.d].toString()}smp(){return this.a.smp(),this.b.smp(),this.c.smp(),this.d.smp(),this}get determinant(){return this.det.value}get inverse(){return this.det.eq(0)?null:new Ct(this.d.div(this.det),this.b.neg.d(this.det),this.c.neg.d(this.det),this.a.div(this.det),this.det.inv).smp()}multiply(t){return new t.constructor(this.a.mul(t._x).a(this.b.mul(t._y)),this.c.mul(t._x).a(this.d.mul(t._y))).smp()}static getTransformMatrix(t,e){if(t.eq(R.ZERO))throw new Error("Cannot transform zero vector.");let i=new Ct(t._x,t._y.neg,t._y,t._x),{_x:s,_y:n}=i.inverse.multiply(e);return new Ct(s,n.neg,n,s)}}var Pt,kt,Tt,Rt;!function(t){function e(t){let e=[];for(let i=0;i<t.length;i++){let[s,n]=[t[i],t[(i+1)%t.length]];s.eq(n)||e.push(new Nt(s,n))}return e}function i(t,e,i=!1){if(e.length<=2)return i&&e[0].contains(t,!0);let s=0,n=new R(1,0);for(let r of e){if(r.p1.eq(t)||r.p2.eq(t))return i;let e=r.intersection(t,n,!0);if(!e)continue;if(e.eq(t))return i;let o=e.eq(r.p1),h=e.eq(r.p2);(!o&&!h||o&&r.p2._y.lt(t._y)||h&&r.p1._y.lt(t._y))&&s++}return s%2==1}function s(t,e){return t.push(...t.splice(0,e)),t}t.triangleTransform=function(t,e){let[i,s,n]=t,[r,o,h]=[e,s,n].map((t=>t.sub(i))),l=Ct.getTransformMatrix(o,r);return i.add(l.multiply(h))},t.collect=function(t){let e=[],i=new Map,n=0;for(let r of t){let t=!1;for(let[o,h]of r.entries()){let l=h.toString(),a=i.get(l);if(a){if(!e[a[0]])continue;e[a[0]].splice(a[1],0,...s(r,o));for(let[t,s]of e[a[0]].entries())i.set(s.toString(),[a[0],t]);t=!0;break}i.set(l,[n,o])}t||(e.push(r),n++)}return{paths:e,map:i}},t.join=function(t,e){t=t.concat(),e=e.concat();for(let i=0;i<t.length;i++)for(let n=0;n<e.length;n++)if(t[i].eq(e[n]))return s(e,n),t.splice(i,2,...e),t;return t},t.shift=function(t,e){return t.map((t=>t.add(e)))},t.polygonIntersect=function(t,s){let n=e(t),r=e(s);return t.some((t=>i(t,r)))||s.some((t=>i(t,n)))},t.lineInsidePath=function(t,s){let n=e(s);return i(t.p1,n,!0)&&i(t.p2,n,!0)},t.pointInsidePath=function(t,s){return i(t,e(s))}}(Pt||(Pt={}));class Et{constructor(t,e){t._x.gt(e._x)&&([t,e]=[e,t]),t._y.gt(e._y)&&([t,e]=[new T(t._x,e._y),new T(e._x,t._y)]),[this.p1,this.p2]=[t,e]}contains(t){return this.p1._x.le(t.p1._x)&&this.p1._y.le(t.p1._y)&&this.p2._x.ge(t.p2._x)&&this.p2._y.ge(t.p2._y)}equals(t){return this.p1.eq(t.p1)&&this.p2.eq(t.p2)}get width(){return this.p2._x.sub(this.p1._x).value}get height(){return this.p2._y.sub(this.p1._y).value}get top(){return this.p2.y}get right(){return this.p2.x}}!function(t){function e(t,e,i){let s=[],n=t.length-1;do{s.push(t[n])}while(!t[n--].eq(e));if(!(s.length<=2))for(let t of i)Pt.lineInsidePath(t,s)&&i.delete(t)}function s(t,e,i){return null!=t&&(null==e||t.dist.lt(e.dist)||t.dist.eq(e.dist)&&t.angle*i<e.angle*i)}function n(t,e,i){var s=t.p2.sub(t.p1),n=new Ct(s._x,i._x,s._y,i._y).inverse;if(null==n)return null;var o=n.multiply(new T(e.sub(t.p1))),h=o._x,l=o._y.neg;return h.lt(0)||h.gt(1)||l.lt(0)?null:{point:e.add(i.scale(l)),dist:l,angle:r(i,s)}}function r(t,e){for(var i=t.angle-e.angle;i<0;)i+=Math.PI;for(;i>Math.PI;)i-=Math.PI;return i}function o(t,e,i,s,n){let o=i.rotate90(),h=t.p1.sub(e),l=t.p2.sub(e),a=h.dot(o),d=l.dot(o),c=h.dot(i),u=l.dot(i);return(a*s>0||d*s>0)&&(c>0||u>0||!!n&&r(i,t.vector)*s>n*s)}t.create=function(t,h,l,a,d,c){let u,p,g,f=[],y=[],v=l,_=h,x=new Set,m=new Set(t);i&&console.log([...a].toString());do{u=null;for(let t of m){let e=n(t,_,v);if(e){let n=p?r(v,p):void 0,h=a.has(e.point.toString())?-1:1;if(!o(t,_,v,h,n))continue;i&&console.log([JSON.stringify(e),t.toString()]),s(e,u,h)&&(u=e,g=t)}}if(u){let t=u.point,s=new Nt(_,t);if(c){let t=s.intersection(c);t&&(y.push(t),c=void 0)}let n=s.intersection(d);if(n){y.push(n);break}let r=t.toString();x.has(r)?e(f,t,m):x.add(r),f.push(t),c||y.length&&y[y.length-1].eq(t)||y.push(t),p=g.vector,v=g.reflect(v),i&&console.log([t.toString(),g.toString(),v.toString(),p.toString()]),_=t,m.delete(g)}}while(null!=u);return y}}(kt||(kt={})),function(t){function e(t,e){return{c:Ht(t.c),ox:t.ox,oy:t.oy,parent:e}}t.joinOverlaps=function(t,e,i,s,n,r=!1){r&&([t,e]=[e,t],[i,s]=[s,i]);let o=n?0:2,h=((e.ox>t.ox?3:1)+o)%4;return e.c[o]={type:mt.coincide,e:i,q:o},e.c[h]={type:mt.intersection,e:t.c[It(o)].e},t.c[It(h)]={type:mt.coincide,e:s,q:h},e},t.cut=function(t,i,s,n,r){let o=e(t,i),h=e(t,i);return n>0?(o.c[2]={type:mt.internal,e:s-1,q:3},o.c[1]={type:mt.socket,e:s-1,q:0},o.ox=n,h.c[3]={type:mt.socket,e:s,q:2},h.c[0]={type:mt.internal,e:s,q:1},h.ox=t.ox-n,h.shift={x:n,y:0}):(o.c[2]={type:mt.internal,e:s-1,q:1},o.c[3]={type:mt.socket,e:s-1,q:0},o.oy=r,h.c[1]={type:mt.socket,e:s,q:2},h.c[0]={type:mt.internal,e:s,q:3},h.oy=t.oy-r,h.shift={x:0,y:r}),[{overlaps:[o]},{overlaps:[h]}]},t.toOverlap=e}(Tt||(Tt={})),function(t){t.halfIntegral="HALFINTEGRAL",t.universal="UNIVERSAL",t.baseJoin="BASE_JOIN",t.standardJoin="STANDARD_JOIN",t.perfect="PERFECT"}(Rt||(Rt={}));class Dt{constructor(t,e){this.repo=t,this.seed=null==e?void 0:e.configuration,this.seedSignature=JSON.stringify(this.seed),this.pattern=null==e?void 0:e.pattern}*generate(t){if(this.seed&&this.pattern)try{let t=new W(this.repo,this.seed,this.pattern);if(!t.entry)throw!0;yield t}catch(t){this.seedSignature=void 0,console.log("Incompatible old version.")}yield*Bt.filter(this.search(),(t=>!this.seedSignature||this.seedSignature!=JSON.stringify(t))),t()}*search(){const t=this.repo.structure,e=t=>null!=t.entry;if(1==t.length){let[i]=t;yield*Bt.first([this.searchSingleGadget(i),this.searchDoubleRelay(i,0),this.searchSingleGadget(i,Rt.halfIntegral),this.searchSingleGadget(i,Rt.universal)],e)}if(2==t.length){let i=t;yield*Bt.first([this.searchThreeFlapJoin(i,Rt.perfect),this.searchThreeFlapRelay(i),this.searchThreeFlapJoin(i),this.searchThreeFlapRelayJoin(i),this.searchThreeFlapJoin(i,Rt.baseJoin),this.searchThreeFlapRelayJoin(i,Rt.baseJoin),this.searchThreeFlapJoin(i,Rt.standardJoin),this.searchThreeFlapRelayJoin(i,Rt.standardJoin),this.searchThreeFlapRelay(i,Rt.halfIntegral)],e)}}*searchSingleGadget(t,e){yield new W(this.repo,{partitions:[{overlaps:[Tt.toOverlap(t,0)],strategy:e}]})}*searchDoubleRelay(t,e){if(!(t.ox*t.oy%2))if(t.ox<t.oy)for(let i=1;i<=t.oy/2;i++){let s=new W(this.repo,{partitions:Tt.cut(t,e,-1,0,i)});s.entry&&(yield s,yield new W(this.repo,{partitions:Tt.cut(t,e,-1,0,t.oy-i)}))}else for(let i=1;i<=t.ox/2;i++){let s=new W(this.repo,{partitions:Tt.cut(t,e,-1,i,0)});s.entry&&(yield s,yield new W(this.repo,{partitions:Tt.cut(t,e,-1,t.ox-i,0)}))}}*searchThreeFlapRelay(t,e){let[i,s]=t.map(((t,e)=>Tt.toOverlap(t,e))),n=i.c[2].e==s.c[2].e;i.ox>s.ox&&([i,s]=[s,i]);let[r,o]=Ht([i,s]);o.ox-=i.ox,r.oy-=s.oy;let[h,l,a,d]=n?[0,1,2,3]:[2,3,0,1];o.c[a]={type:mt.internal,e:-1,q:d},o.c[l]={type:mt.intersection,e:i.c[h].e},i.c[d]={type:mt.socket,e:-2,q:a},r.c[a]={type:mt.internal,e:-2,q:l},r.c[d]={type:mt.intersection,e:s.c[h].e},s.c[l]={type:mt.socket,e:-1,q:a},n||(o.shift={x:i.ox,y:0},r.shift={x:0,y:s.oy}),yield new W(this.repo,{partitions:[{overlaps:[i],strategy:e},{overlaps:[o],strategy:e}]}),yield new W(this.repo,{partitions:[{overlaps:[r],strategy:e},{overlaps:[s],strategy:e}]})}*searchThreeFlapJoin(t,e){let[i,s]=t.map(((t,e)=>Tt.toOverlap(t,e)));Tt.joinOverlaps(i,s,-1,-2,i.c[0].e==s.c[0].e),yield new W(this.repo,{partitions:[{overlaps:[i,s],strategy:e}]})}*searchThreeFlapRelayJoin(t,e){let[i,s]=t.map(((t,e)=>Tt.toOverlap(t,e))),n=i.c[0].e==s.c[0].e,r=s.ox>i.ox,o=(r?i:s).ox,h=(r?s:i).oy;for(let t=1;t<o;t++){let[o,h]=Ht([i,s]),l=Tt.joinOverlaps(o,h,-1,-2,n,!r);l.ox-=t,n&&(l.shift={x:t,y:0}),yield new W(this.repo,{partitions:[{overlaps:[o,h],strategy:e}]})}for(let t=1;t<h;t++){let[o,h]=Ht([i,s]),l=Tt.joinOverlaps(o,h,-1,-2,n,r);l.oy-=t,n&&(l.shift={x:0,y:t}),yield new W(this.repo,{partitions:[{overlaps:[o,h],strategy:e}]})}}}let Ot=class extends Y{constructor(t,e,i){var s,n,r;super(t.sheet),this.pattern=t,this.partition=e;let{fx:o,fy:h}=t.stretch;this.gadgets=i.gadgets.map((t=>jt.instantiate(t))),this.addOns=null!==(n=null===(s=i.addOns)||void 0===s?void 0:s.map((t=>u.instantiate(t))))&&void 0!==n?n:[];let l=null!==(r=i.offset)&&void 0!==r?r:0;this.location={x:l*o,y:l*h},this.view=new Gt(this)}get type(){return"Device"}toJSON(){return{gadgets:this.gadgets.map((t=>t.toJSON())),offset:this.offset,addOns:this.addOns.length?this.addOns:void 0}}get _origin(){return this._originalDisplacement||(this._originalDisplacement=this.partition.getOriginalDisplacement(this.pattern)),this.pattern.stretch.origin.add(this._originalDisplacement)}get shouldDispose(){return super.shouldDispose||this.pattern.disposed}get isActive(){return this.pattern.isActive}get anchors(){let t=[],{fx:e,fy:i}=this.pattern.stretch;for(let s of this.gadgets)t.push(s.anchorMap.map((t=>{if(!t[0])debugger;return t[0].transform(e,i).add(this.delta)})));return t}get delta(){return this._origin.add(new R(this.location)).sub(T.ZERO)}get regions(){let t=[];for(let e of this.gadgets)t.push(...e.pieces);return t.push(...this.addOns),t}get regionRidges(){let t=new Map;for(let e of this.regions){let i=this.regions.filter((t=>t!=e&&t.direction.parallel(e.direction))).reduce(((t,e)=>(t.push(...e.shape.ridges.filter((t=>!t.perpendicular(e.direction)))),t)),[]);t.set(e,Nt.subtract(e.shape.ridges,i))}return t}get rawRidges(){let{fx:t,fy:e}=this.pattern.stretch,i=[],s=this.regionRidges;for(let n of this.regions)i.push(...s.get(n).map((i=>i.transform(t,e).shift(this.delta))));return Nt.distinct(i)}get ridges(){return Nt.subtract(this.rawRidges,this.neighbors.reduce(((t,e)=>(t.push(...e.rawRidges),t)),[]))}get axisParallels(){let{fx:t,fy:e}=this.pattern.stretch,i=[];for(let s of this.regions)for(let n of s.axisParallels)i.push(n.transform(t,e).shift(this.delta));return i}get outerRidges(){if(!this.isActive)return[];let t=this.getConnectionRidges();for(let[e,i]of this.intersectionMap)i&&t.push(new Nt(e,i));return Nt.distinct(t)}get intersectionMap(){let t=[];if(!this.isActive)return t;for(let[e,i,s]of this.partition.intersectionCorners){let n=this.anchors[i][s],r=this.partition.getSideConnectionTarget(n,e);t.push([n,r])}return t}get openAnchors(){return this.intersectionMap.filter((t=>!t[1]||t[0].eq(t[1]))).map((t=>t[0]))}getConnectionRidges(t=!1){let e=[];for(let[i,s]of this.partition.overlaps.entries())for(let[n,r]of s.c.entries())(r.type==mt.flap&&!t||r.type==mt.internal)&&e.push(new Nt(this.anchors[i][n],this.pattern.getConnectionTarget(r)));return e}constraint(t,e){let{fx:i,fy:s}=this.pattern.stretch,n=i*s,r=Math.round((t.x+n*t.y)/2);for(let[t,e,i]of this.partition.constraints)r=this.fix(r,t,e,i);return new R(r,n*r)}get neighbors(){let t=new Set;for(let e of this.partition.overlaps)for(let i of e.c)if(i.type==mt.socket||i.type==mt.internal){let[e]=this.partition.configuration.overlapMap.get(i.e);t.add(this.pattern.devices[e])}return Array.from(t)}fix(t,e,i,s){let n=e.type!=mt.socket,r=this.pattern.stretch.fx*(0==(n?s:It(e.q))?-1:1),o=this.pattern.getConnectionTarget(e),h=n?this.gadgets[i].slacks[s]:this.pattern.gadgets[-e.e-1].slacks[e.q],l=o.x-this.anchors[i][s].x-h*r;return t*r>l*r&&(t=l),t}get offset(){let t=this.partition.getOriginalDisplacement(this.pattern).x;return t-=this._originalDisplacement.x,(this.location.x-t)*this.pattern.stretch.fx}};t([e],Ot.prototype,"isActive",null),t([e],Ot.prototype,"anchors",null),t([e],Ot.prototype,"delta",null),t([o],Ot.prototype,"regions",null),t([o],Ot.prototype,"regionRidges",null),t([e],Ot.prototype,"rawRidges",null),t([e],Ot.prototype,"ridges",null),t([e],Ot.prototype,"axisParallels",null),t([e],Ot.prototype,"outerRidges",null),t([e],Ot.prototype,"intersectionMap",null),t([e],Ot.prototype,"openAnchors",null),t([e],Ot.prototype,"neighbors",null),Ot=t([e],Ot);class jt{constructor(t){this.pieces=t.pieces.map((t=>c.instantiate(t))),this.offset=t.offset,this.pieces.forEach((t=>t.offset(this.offset))),this.anchors=t.anchors}toJSON(){return Ht(this)}get anchorMap(){return Mt((t=>{var e,i;if(null===(i=null===(e=this.anchors)||void 0===e?void 0:e[t])||void 0===i?void 0:i.location){let e=new T(this.anchors[t].location);return this.offset&&e.addBy(new R(this.offset)),[e,null]}if(1==this.pieces.length)return[this.pieces[0].anchors[t],0];for(let[e,i]of this.pieces.entries())if(i.anchors[t])return[i.anchors[t],e];debugger;throw new Error}))}_getSlack(t){var e,i,s;return null!==(s=null===(i=null===(e=this.anchors)||void 0===e?void 0:e[t])||void 0===i?void 0:i.slack)&&void 0!==s?s:0}get slacks(){return Mt((t=>this._getSlack(t)))}get sx(){return Math.ceil(this.anchorMap[2][0].x-this.anchorMap[0][0].x)}get sy(){return Math.ceil(this.anchorMap[2][0].y-this.anchorMap[0][0].y)}reverseGPS(){let t=jt.instantiate(this.toJSON()),[e,i]=t.pieces,s=Math.ceil(Math.max(e.sx,i.sx)),n=Math.ceil(Math.max(e.sy,i.sy));return e.reverse(s,n),i.reverse(s,n),t}addSlack(t,e){var i;return this.anchors=this.anchors||[],this.anchors[t]=this.anchors[t]||{},this.anchors[t].slack=(null!==(i=this.anchors[t].slack)&&void 0!==i?i:0)+e,this}setupConnectionSlack(t,e,i){let s=this.contour,n=t.contour,r=0==e?1:-1,o=new R(r,r),h=t.anchorMap[i][0].sub(T.ZERO).addBy(o.scale(this._getSlack(e)));s=Pt.shift(s,0==e?h:h.add(T.ZERO.sub(this.anchorMap[2][0])));let l=0;for(;Pt.polygonIntersect(s,n);)s=Pt.shift(s,o),l++;return this.addSlack(e,l),l}get contour(){let t=this.pieces,e=t[0].shape.contour;for(let i=1;i<t.length;i++)e=Pt.join(e,t[i].shape.contour);return e}rx(t,e){return Math.abs(this.anchorMap[t][0].x-this.anchorMap[e][0].x)}ry(t,e){return Math.abs(this.anchorMap[t][0].y-this.anchorMap[e][0].y)}contains(t){return this.pieces.some((e=>Pt.pointInsidePath(t,e.shape.contour)))}static instantiate(t){return t instanceof jt?t:new jt(t)}static simplify(t){if(t.offset&&0==t.offset.x&&0==t.offset.y&&delete t.offset,t.anchors){for(let[e,i]of t.anchors.entries())i&&(0===i.slack&&delete i.slack,0==Object.keys(i).length&&delete t.anchors[e]);t.anchors.some((t=>!!t))||delete t.anchors}return t}}t([o],jt.prototype,"anchorMap",null),t([o],jt.prototype,"slacks",null),t([o],jt.prototype,"sx",null),t([o],jt.prototype,"sy",null),t([o],jt.prototype,"contour",null);class At{constructor(t,e){let i=[],[s,n]=t;if(s.ox==n.ox||s.oy==n.oy)return;[this.g1,this.g2]=t.map((t=>{let s=e.structure[t.parent];return i.push(s),Array.from(c.gops(t,s.sx))}));let[r,o]=i;this.oriented=r.c[0].e==o.c[0].e,this.cw=s.ox>n.ox,this.q=this.oriented?0:2,[this.q1,this.q2]=this.oriented?this.cw?[2,1]:[1,2]:this.cw?[0,3]:[3,0],this.intDist=l.getMaxIntersectionDistance(e.sheet.design.tree,r,o,this.oriented),[this.s1,this.s2]=this.oriented?[s.shift,n.shift]:[this.getReverseShift(s,r),this.getReverseShift(n,o)]}*join(t,e){let{g1:i,g2:s}=this,n=[];if(i){for(let r of i)for(let i of s){let s=c.instantiate(r,!0),o=c.instantiate(i,!0);e&&!e(s,o)||n.push(...t(new Jt(this,s,o)))}n.sort(((t,e)=>t[1]-e[1]));for(let[t]of n)yield t}}*simpleJoin(t){let{s1:e,s2:i}=this;yield*this.join((t=>t.simpleJoin()),((s,n)=>{let r=s.direction.parallel(n.direction);return!(t==Rt.perfect&&!r)&&(!e&&!i||!r)}))}*baseJoin(){yield*this.join((t=>t.baseJoin()))}*standardJoin(){let{s1:t,s2:e}=this,i=!!t||!!e,s=0;yield*this.join((t=>t.standardJoin()),((t,e)=>i||0==s++))}getReverseShift(t,e){var i,s,n,r;let o=t.ox+(null!==(s=null===(i=t.shift)||void 0===i?void 0:i.x)&&void 0!==s?s:0),h=t.oy+(null!==(r=null===(n=t.shift)||void 0===n?void 0:n.y)&&void 0!==r?r:0);if(o!=e.ox||h!=e.oy)return{x:o-e.ox,y:h-e.oy}}getRelayJoinIntersection(t,e,i){let s=this.oriented?new R(1,1):new R(-1,-1),n=t.anchors[this.q].sub(new R(e));return t.shape.ridges[i].intersection(n,s)}}class Jt{constructor(t,e,i){let{oriented:s,s1:n,s2:r,q1:o,q2:h,q:l}=this.joiner=t,a=[],d=[],c=e.sx+i.sx,u={x:0,y:0},p={x:0,y:0};if(n){let r=t.getRelayJoinIntersection(i,n,(o+2)%4);if(!r||!r.isIntegral)return;s?(e.offset(u=r.toIPoint()),c+=u.x,a[l]={location:{x:-u.x,y:-u.y}}):(i.offset(p={x:i.sx-r.x,y:i.sy-r.y}),c+=p.x,a[l]={location:{x:e.sx+p.x,y:e.sy+p.y}})}if(r){let n=t.getRelayJoinIntersection(e,r,(h+2)%4);if(!n||!n.isIntegral)return;s?(i.offset(p=n.toIPoint()),c+=p.x,d[l]={location:{x:-p.x,y:-p.y}}):(i.offset(p={x:n.x-e.sx,y:n.y-e.sy}),c-=p.x,d[l]={location:{x:i.sx-p.x,y:i.sy-p.y}})}let g,f=R.ZERO;s||(g={x:e.sx-i.sx,y:e.sy-i.sy},f=new R(g));let y=new R(u).neg,v=new R(p).addBy(f).neg,_=n?e.anchors[l]:i.anchors[l].add(f),x=_.add(y).toIPoint(),m=_.add(v).toIPoint(),w=e.shape.ridges[o],b=i.shape.ridges[h].shift(f),S=R.bisector(e.direction,i.direction),M=s?T.ZERO:n?new T(a[l].location):e.anchors[l],q=s?1:-1;this.data={p1:e,p2:i,v1:y,v2:v,a1:a,a2:d,off1:u,off2:p,offset:g,size:c,pt:_,pt1:x,pt2:m,e1:w,e2:b,bv:S,org:M,f:q}}*simpleJoin(){if(!this.data)return;let{e1:t,e2:e,p1:i,p2:s,pt:n,bv:r}=this.data,o=t.intersection(e);o&&(i.direction.parallel(s.direction)||o.sub(n).parallel(r))&&this.setupAnchor(o)&&(this.setupDetour([o],[o]),yield this.result())}get deltaPt(){let{org:t,p1:e,p2:i,f:s}=this.data,{cw:n,intDist:r}=this.joiner;return new T(t.x+(r-(n?i:e).ox)*s,t.y+(r-(n?e:i).oy)*s)}baseJoinIntersections(){let{bv:t,e1:e,e2:i,pt:s}=this.data,n=new Nt(this.deltaPt,j.QV[0]),r=new Nt(s,t);return{D1:e.intersection(n),D2:i.intersection(n),B1:e.intersection(r),B2:i.intersection(r),delta:n}}*baseJoin(){if(!this.data)return;let{D1:t,D2:e,B1:i,B2:s}=this.baseJoinIntersections();if((null==i?void 0:i.isIntegral)&&(null==e?void 0:e.isIntegral)&&!i.eq(e)){if(!this.setupAnchor(e))return;this.setupDetour([i],[e,i]),yield this.result(!0)}if((null==s?void 0:s.isIntegral)&&(null==t?void 0:t.isIntegral)&&!s.eq(t)){if(!this.setupAnchor(t))return;this.setupDetour([t,s],[s]),yield this.result()}}substituteEnd(t,e){let[i,s]=t.xOrient();return new Nt(e,this.joiner.oriented?s:i)}closestGridPoint(t,e){let i,s=Number.POSITIVE_INFINITY;for(let n of t.gridPoints()){let t=n.dist(e);t<s&&(s=t,i=n)}return i}*standardJoin(){if(!this.data)return;let{D1:t,D2:e,B1:i,B2:s,delta:n}=this.baseJoinIntersections(),{f:r}=this.data;i&&e&&!i.eq(e)&&(e.x*r>i.x*r?yield*this.obtuseStandardJoin(i,e,0):yield*this.acuteStandardJoin(i,e,1,n)),s&&t&&!s.eq(t)&&(t.x*r>s.x*r?yield*this.obtuseStandardJoin(s,t,1):yield*this.acuteStandardJoin(s,t,0,n))}*obtuseStandardJoin(t,e,i){if(t.isIntegral)return;let{e1:s,e2:n,p1:r,p2:o,pt:h,f:l}=this.data,{cw:a}=this.joiner,d=[s,n][i],c=[r,o][i];if(a!=r.direction.slope.gt(o.direction.slope))return;if(!this.setupAnchor(e))return;let u=e.sub(t).slope.gt(1)?d.xIntersection(e.x):d.yIntersection(e.y),p=this.closestGridPoint(this.substituteEnd(d,t),e);if(p.eq(d.p1)||p.eq(d.p2))return;let g=Pt.triangleTransform([e,u,t],p);g.x*l<h.x*l||(this.data.addOns=[{contour:[e,p,g].map((t=>t.toIPoint())),dir:new Nt(p,g).reflect(c.direction).toIPoint()}],this.setupDetour([0==i?p:e,g],[0==i?e:p,g]),yield this.result(!0,g.dist(p)))}*acuteStandardJoin(t,e,i,s){if(e.isIntegral)return;let{e1:n,e2:r,p1:o,p2:h}=this.data,l=[n,r][i],a=[o,h][i],d=this.closestGridPoint(this.substituteEnd(l,e),t);if(d.eq(l.p1)||d.eq(l.p2))return;let c=e.sub(t).slope.gt(1)?s.yIntersection(d.y):s.xIntersection(d.x),u=Pt.triangleTransform([d,e,c],t);this.setupAnchor(u)&&(this.data.addOns=[{contour:[t,d,u].map((t=>t.toIPoint())),dir:new Nt(d,t).reflect(a.direction).toIPoint()}],this.setupDetour(0==i?[d,t]:[t],0==i?[t]:[d,t]),yield this.result(!0,t.dist(d)))}setupDetour(t,e){let{p1:i,p2:s,v1:n,v2:r,pt1:o,pt2:h}=this.data,l=t.map((t=>t.add(n).toIPoint()));l.push(o);let a=e.map((t=>t.add(r).toIPoint()));a.push(h),(this.joiner.cw?a:l).reverse(),i.clearDetour(),i.addDetour(l),s.clearDetour(),s.addDetour(a)}setupAnchor(t){let{a1:e,a2:i,v1:s,v2:n,f:r}=this.data,{oriented:o,cw:h}=this.joiner;if(t.x*r>this.deltaPt.x*r)return!1;let l=o==h;return e[l?3:1]={location:t.add(s).toIPoint()},i[l?1:3]={location:t.add(n).toIPoint()},!0}result(t=!1,e){let{p1:i,p2:s,a1:n,a2:r,off1:o,off2:h,offset:l,size:a,addOns:d}=this.data;return this.data.addOns=void 0,l&&(h={x:h.x+l.x,y:h.y+l.y}),[{gadgets:[{pieces:[t?i.toJSON():i],offset:this.simplifyIPoint(o),anchors:n.concat()},{pieces:[t?s.toJSON():s],offset:this.simplifyIPoint(h),anchors:r.concat()}],addOns:d},a+10*(null!=e?e:0)]}simplifyIPoint(t){return t&&0==t.x&&0==t.y?void 0:t}}t([o],Jt.prototype,"deltaPt",null);let $t=class extends ${constructor(t,e,i){super(t.sheet),this.joinerCache=new Map,this.stretch=t,this.signature=e,this.structure=JSON.parse(e),this.generator=new Dt(this,i).generate((()=>this.joinerCache.clear()))}builder(t){return t}get isActive(){return this.stretch.isActive&&this.stretch.repository==this}onMove(){this.stretch.selected=!this.entry.entry.selected}getJoiner(t){let e=JSON.stringify(t),i=this.joinerCache.get(e);return i||this.joinerCache.set(e,i=new At(t,this)),i}};var Lt,Bt,Vt,Ft,Wt;function zt(t,...e){for(let i of e)if(i instanceof Object){let e=Object.keys(i);for(let s of e){let e=i[s];e instanceof Object?t[s]instanceof Object&&t[s]!=e?t[s]=zt(t[s],e):t[s]=Ht(e):t[s]=e}}return t}function Ht(t){return zt(t instanceof Array?[]:{},t)}t([e],$t.prototype,"isActive",null),$t=t([e],$t),function(t){t.parse=function(t,s){try{let n=new e(s),{result:r}=new i(n);return r.title=t,r}catch(t){throw"string"==typeof t?new Error(t):new Error("plugin.TreeMaker.invalid")}};class e{constructor(t){this.lines=t.split("\n").values()}get next(){return this.lines.next().value.trim()}get int(){return parseInt(this.next)}get float(){return parseFloat(this.next)}get bool(){return"true"==this.next}skip(t){for(let e=0;e<t;e++)this.lines.next()}skipArray(){this.skip(this.int)}}class i{constructor(t){if(this.result=ct.getSample(),this.set=new Set,this._visitor=t,"tree"!=t.next||"5.0"!=t.next)throw"plugin.TreeMaker.not5";let e=t.float,i=t.float,s=1/t.float;t.skip(11);let n=t.int,r=t.int;t.skip(6);for(let t=0;t<n;t++)this.parseNode();for(let t=0;t<r;t++)this.parseEdge();let o=Ft.LCM(Array.from(this.set)),h=Math.ceil(e*s*o-.25),l=Math.ceil(i*s*o-.25);if(h<8||l<8)throw"plugin.TreeMaker.size8";let a=h/e,d=l/i;for(let t of this.result.layout.flaps)t.x=Math.round(t.x*a),t.y=Math.round(t.y*d);for(let t of this.result.tree.nodes)t.x=Math.round(t.x*a),t.y=Math.round(t.y*d);for(let t of this.result.tree.edges)t.length=Math.max(Math.round(t.length*o),1);let c={width:h,height:l,scale:20};this.result.layout.sheet=c,this.result.tree.sheet=c}parseNode(){let t=this._visitor;if("node"!=t.next)throw new Error;let e={id:t.int,name:t.next,x:t.float,y:t.float};t.skip(2),t.bool&&this.result.layout.flaps.push({id:e.id,x:e.x,y:e.y,height:0,width:0}),this.result.tree.nodes.push(e),t.skip(6),t.skipArray(),t.skipArray(),t.skipArray(),"1"==t.next&&t.next}parseEdge(){let t=this._visitor;if("edge"!=t.next)throw new Error;t.skip(2);let e=t.float;this.set.add(Number(v.toFraction(e,1,0,.1).$denominator)),this.result.tree.edges.push({length:e*(1+t.float),n1:(t.skip(4),t.int),n2:t.int})}}}(Lt||(Lt={})),function(t){t.first=function*(t,e){for(let i of t){let t=!1;for(let s of i)e(s)&&(yield s,t=!0);if(t)return}},t.filter=function*(t,e){for(let i of t)e(i)&&(yield i)}}(Bt||(Bt={})),function(t){let e=new WeakMap;function i(t,e,i,s,n,r){t.justification=0==n?"center":1==n?"left":"right";let o=0==r?-s/5:-1==r?-s/2:0,h=Math.sqrt(n*n+r*r),l=0==h?0:s/2/h;t.point.set(e+n*l,i-r*l-o)}t.setLabel=function(t,s,n,r,...o){if(n.content=s.content,!s.content)return;let h=r.x,l=r.y,a=t.displayScale,d=t.width,c=t.height,u=s.bounds.height,p=h*a,g=-l*a;if(0==h||0==l||h==d||l==c){i(s,p,g,u,0==h?-1:h==d?1:0,0==l?-1:l==c?1:0)}else!function(t,s,n,r,o){let h=[[0,0],[0,-1],[-1,0],[0,1],[1,0],[-1,-1],[-1,1],[1,1],[1,-1]],l=o.map((t=>{let e=t.clone({insert:!1});return t.layer&&e.transform(t.layer.matrix),e})),a=0,d=0;for([a,d]of h){i(t,s,n,r,a,d);let e=new paper.Path.Rectangle(t.bounds);if(t.layer&&e.transform(t.layer.matrix),l.every((t=>{let i=e.intersect(t,{insert:!1}).isEmpty(),s=!e.intersects(t);return i&&s})))break}e.set(t,{dx:a,dy:d,timeout:void 0})}(s,p,g,u,o);!function(t,e){e.point.set(t.point),e.justification=t.justification}(s,n)}}(Vt||(Vt={})),function(t){function e(t,e){if("number"==typeof t&&!Number.isSafeInteger(t))throw new Error("Not a safe integer: "+t);if("number"==typeof e&&!Number.isSafeInteger(e))throw new Error("Not a safe integer: "+e);if(0==t&&0==e)throw new Error("Input cannot be both zero");for(t<0&&(t=-t),e<0&&(e=-e);t&&e;)(t%=e)&&(e%=t);return t||e}t.GCD=e,t.LCM=function(t){let i=t[0];for(let s=1;s<t.length;s++){let n=e(i,t[s]);i=i*t[s]/n}return i},t.reduce=function(t,e){if("number"==typeof t&&!Number.isInteger(t)||"number"==typeof e&&!Number.isInteger(e)){let i=new v(t),s=new v(e);t=Number(i.$numerator*s.$denominator),e=Number(i.$denominator*s.$numerator)}let i=this.GCD(t,e);return[t/i,e/i]},t.int=function(t,e){return e>0?Math.ceil(t):Math.floor(t)}}(Ft||(Ft={})),function(t){let e,i;t.replaceContent=function(t,e,i){t.removeChildren(),e instanceof paper.CompoundPath?t.copyContent(e):(i&&(e=e.clone({insert:!1})),t.addChild(e))},t.setRectangleSize=function(t,e,i){t.segments[1].point.set(e,0),t.segments[2].point.set(e,i),t.segments[3].point.set(0,i)},t.addLine=function(t,e,i){e instanceof T&&(e=e.toPaper()),i instanceof T&&(i=i.toPaper()),t.moveTo(e),t.lineTo(i)},t.setLines=function(e,...i){e.removeChildren();for(let s of i)for(let i of s)t.addLine(e,i.p1,i.p2)},t.Black=function(){return e=e||new paper.Color("black")},t.Red=function(){return i=i||new paper.Color("red")}}(Wt||(Wt={}));let Gt=class extends L{constructor(t){super(t),this.$addItem(xt.axisParallel,this._axisParallels=new paper.CompoundPath(bt.axisParallel)),this.$addItem(xt.ridge,this._ridges=new paper.CompoundPath(bt.ridge)),this.$addItem(xt.shade,this._shade=new paper.CompoundPath(bt.shade))}contains(t){return this._shade.contains(t)}render(){let t=null;for(let e of this.control.regions){let i=this.contourToPath(e.shape.contour);t=t?t.unite(i,{insert:!1}):i}Wt.replaceContent(this._shade,t,!1),Wt.setLines(this._ridges,this.control.ridges,this.control.outerRidges),Wt.setLines(this._axisParallels,this.control.axisParallels)}contourToPath(t){let e=new paper.Path({closed:!0}),{fx:i,fy:s}=this.control.pattern.stretch,n=this.control.delta;return t.forEach((t=>e.add(t.transform(i,s).add(n).toPaper()))),e}renderSelection(t){this._shade.visible=t||this.control.pattern.configuration.repository.stretch.selected}};return Gt=t([e],Gt),rt}));