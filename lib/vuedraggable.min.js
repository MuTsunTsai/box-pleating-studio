/** VueDraggable 2.24.3 custom built by MuTsunTsai */
!function(){const t="undefined"!=typeof window?window.console:global.console;const e=/-(\w)/g,n=function(t){const e=Object.create(null);return function(n){return e[n]||(e[n]=t(n))}}(t=>t.replace(e,(t,e)=>e?e.toUpperCase():""));function i(t){null!==t.parentElement&&t.parentElement.removeChild(t)}function o(t,e,n){const i=0===n?t.children[0]:t.children[n-1].nextSibling;t.insertBefore(e,i)}function s(t,e){this.$nextTick(()=>this.$emit(t.toLowerCase(),e))}function r(t){return e=>{null!==this.realList&&this["onDrag"+t](e),s.call(this,t,e)}}function a(t){return["transition-group","TransitionGroup"].includes(t)}function l(t,e,n){return t[n]||(e[n]?e[n]():void 0)}const d=["Start","Add","Remove","Update","End"],h=["Choose","Unchoose","Sort","Filter","Clone"],u=["Move",...d,...h].map(t=>"on"+t);var c=null;const p={name:"draggable",inheritAttrs:!1,props:{options:Object,list:{type:Array,required:!1,default:null},value:{type:Array,required:!1,default:null},noTransitionOnDrag:{type:Boolean,default:!1},clone:{type:Function,default:t=>t},element:{type:String,default:"div"},tag:{type:String,default:null},move:{type:Function,default:null},componentData:{type:Object,required:!1,default:null}},data:()=>({transitionMode:!1,noneFunctionalComponentMode:!1}),render(t){const e=this.$slots.default;this.transitionMode=function(t){if(!t||1!==t.length)return!1;const[{componentOptions:e}]=t;return!!e&&a(e.tag)}(e);const{children:n,headerOffset:i,footerOffset:o}=function(t,e,n){let i=0,o=0;const s=l(e,n,"header");s&&(i=s.length,t=t?[...s,...t]:[...s]);const r=l(e,n,"footer");return r&&(o=r.length,t=t?[...t,...r]:[...r]),{children:t,headerOffset:i,footerOffset:o}}(e,this.$slots,this.$scopedSlots);this.headerOffset=i,this.footerOffset=o;const s=function(t,e){let n=null;const i=(t,e)=>{n=function(t,e,n){return void 0===n||((t=t||{})[e]=n),t}(n,t,e)};if(i("attrs",Object.keys(t).filter(t=>"id"===t||t.startsWith("data-")).reduce((e,n)=>(e[n]=t[n],e),{})),!e)return n;const{on:o,props:s,attrs:r}=e;return i("on",o),i("props",s),Object.assign(n.attrs,r),n}(this.$attrs,this.componentData);return t(this.getTag(),s,n)},created(){null!==this.list&&null!==this.value&&t.error("Value and list props are mutually exclusive! Please set one or another."),"div"!==this.element&&t.warn("Element props is deprecated please use tag props instead. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#element-props"),void 0!==this.options&&t.warn("Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props")},mounted(){if(this.noneFunctionalComponentMode=this.getTag().toLowerCase()!==this.$el.nodeName.toLowerCase()&&!this.getIsFunctional(),this.noneFunctionalComponentMode&&this.transitionMode)throw new Error("Transition-group inside component is not supported. Please alter tag value or remove transition-group. Current tag value: "+this.getTag());const t={};d.forEach(e=>{t["on"+e]=r.call(this,e)}),h.forEach(e=>{t["on"+e]=s.bind(this,e)});const e=Object.keys(this.$attrs).reduce((t,e)=>(t[n(e)]=this.$attrs[e],t),{}),i=Object.assign({},this.options,e,t,{onMove:(t,e)=>this.onDragMove(t,e)});!("draggable"in i)&&(i.draggable=">*"),this._sortable=new Sortable(this.rootContainer,i),this.computeIndexes()},beforeDestroy(){void 0!==this._sortable&&this._sortable.destroy()},computed:{rootContainer(){return this.transitionMode?this.$el.children[0]:this.$el},realList(){return this.list?this.list:this.value}},watch:{options:{handler(t){this.updateOptions(t)},deep:!0},$attrs:{handler(t){this.updateOptions(t)},deep:!0},realList(){this.computeIndexes()}},methods:{getIsFunctional(){const{fnOptions:t}=this._vnode;return t&&t.functional},getTag(){return this.tag||this.element},updateOptions(t){for(var e in t){const i=n(e);-1===u.indexOf(i)&&this._sortable.option(i,t[e])}},getChildrenNodes(){if(this.noneFunctionalComponentMode)return this.$children[0].$slots.default;const t=this.$slots.default;return this.transitionMode?t[0].child.$slots.default:t},computeIndexes(){this.$nextTick(()=>{this.visibleIndexes=function(t,e,n,i){if(!t)return[];const o=t.map(t=>t.elm),s=e.length-i,r=[...e].map((t,e)=>e>=s?o.length:o.indexOf(t));return n?r.filter(t=>-1!==t):r}(this.getChildrenNodes(),this.rootContainer.children,this.transitionMode,this.footerOffset)})},getUnderlyingVm(t){const e=function(t,e){return t.map(t=>t.elm).indexOf(e)}(this.getChildrenNodes()||[],t);if(-1===e)return null;return{index:e,element:this.realList[e]}},getUnderlyingPotencialDraggableComponent:({__vue__:t})=>t&&t.$options&&a(t.$options._componentTag)?t.$parent:!("realList"in t)&&1===t.$children.length&&"realList"in t.$children[0]?t.$children[0]:t,emitChanges(t){this.$nextTick(()=>{this.$emit("change",t)})},alterList(t){if(this.list)return void t(this.list);const e=[...this.value];t(e),this.$emit("input",e)},spliceList(){this.alterList(t=>t.splice(...arguments))},updatePosition(t,e){this.alterList(n=>n.splice(e,0,n.splice(t,1)[0]))},getRelatedContextFromMoveEvent({to:t,related:e}){const n=this.getUnderlyingPotencialDraggableComponent(t);if(!n)return{component:n};const i=n.realList,o={list:i,component:n};if(t!==e&&i&&n.getUnderlyingVm){const t=n.getUnderlyingVm(e);if(t)return Object.assign(t,o)}return o},getVmIndex(t){const e=this.visibleIndexes,n=e.length;return t>n-1?n:e[t]},getComponent(){return this.$slots.default[0].componentInstance},resetTransitionData(t){if(!this.noTransitionOnDrag||!this.transitionMode)return;this.getChildrenNodes()[t].data=null;const e=this.getComponent();e.children=[],e.kept=void 0},onDragStart(t){this.context=this.getUnderlyingVm(t.item),t.item._underlying_vm_=this.clone(this.context.element),c=t.item},onDragAdd(t){const e=t.item._underlying_vm_;if(void 0===e)return;i(t.item);const n=this.getVmIndex(t.newIndex);this.spliceList(n,0,e),this.computeIndexes();const o={element:e,newIndex:n};this.emitChanges({added:o})},onDragRemove(t){if(o(this.rootContainer,t.item,t.oldIndex),"clone"===t.pullMode)return void i(t.clone);const e=this.context.index;this.spliceList(e,1);const n={element:this.context.element,oldIndex:e};this.resetTransitionData(e),this.emitChanges({removed:n})},onDragUpdate(t){i(t.item),o(t.from,t.item,t.oldIndex);const e=this.context.index,n=this.getVmIndex(t.newIndex);this.updatePosition(e,n);const s={element:this.context.element,oldIndex:e,newIndex:n};this.emitChanges({moved:s})},updateProperty(t,e){t.hasOwnProperty(e)&&(t[e]+=this.headerOffset)},computeFutureIndex(t,e){if(!t.element)return 0;const n=[...e.to.children].filter(t=>"none"!==t.style.display),i=n.indexOf(e.related),o=t.component.getVmIndex(i);return-1!==n.indexOf(c)||!e.willInsertAfter?o:o+1},onDragMove(t,e){const n=this.move;if(!n||!this.realList)return!0;const i=this.getRelatedContextFromMoveEvent(t),o=this.context,s=this.computeFutureIndex(i,t);Object.assign(o,{futureIndex:s});return n(Object.assign({},t,{relatedContext:i,draggedContext:o}),e)},onDragEnd(){this.computeIndexes(),c=null}}};"undefined"!=typeof window&&"Vue"in window&&window.Vue.component("draggable",p),window.vuedraggable=p}();
